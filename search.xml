<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【Flutter 1-13】Flutter手把手教程Dart语言——异步、Future、Stream、async、await详解</title>
      <link href="dart-asynchronous-1-13.html"/>
      <url>dart-asynchronous-1-13.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>Dart 代码库中有大量返回<code>Future</code>或<code>Stream</code>对象的函数，这些函数都是<strong>异步</strong>的，它们会在耗时操作执行完毕前直接返回而不会等待耗时操作执行完毕。<br><code>async</code>和<code>await</code>关键字用于实现异步编程，并且让你的代码看起来就像是同步的一样。</p><h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><p>可以通过下面两种方式，获得<code>Future</code>执行完成的结果：</p><ul><li>使用<code>async</code>和<code>await</code>；</li><li>使用<code>Future API</code>；</li></ul><p>使用<code>async</code>和<code>await</code>的代码是异步的，但是看起来有点像同步代码。例如，下面的代码使用<code>await</code>等待异步函数的执行结果。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> lookUpVersion();</span><br></pre></td></tr></table></figure><p>必须在带有<code>async</code>关键字的<strong>异步函数</strong>中使用 <code>await</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future checkVersion() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> version = <span class="keyword">await</span> lookUpVersion();</span><br><span class="line">  <span class="comment">// 使用 version 继续处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管异步函数可以处理耗时操作，但是它并不会等待这些耗时操作完成，异步函数执行时会在其遇到第一个 <code>await</code>表达式的时候返回一个<code>Future</code>对象，然后等待<code>await</code>表达式执行完毕后继续执行。</p><p>使用<code>try</code>、<code>catch</code>以及<code>finally</code>来处理使用<code>await</code>导致的异常：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  version = <span class="keyword">await</span> lookUpVersion();</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// 无法找到版本时做出的反应</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以在异步函数中多次使用<code>await</code>关键字。例如，下面代码中等待了三次函数结果：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> entrypoint = <span class="keyword">await</span> findEntrypoint();</span><br><span class="line"><span class="keyword">var</span> exitCode = <span class="keyword">await</span> runExecutable(entrypoint, args);</span><br><span class="line"><span class="keyword">await</span> flushThenExit(exitCode);</span><br></pre></td></tr></table></figure><p><code>await</code>表达式的返回值通常是一个<code>Future</code>对象；<br>如果不是的话也会自动将其包裹在一个<code>Future</code>对象里。<code>Future</code>对象代表一个”承诺”,<code>await</code>表达式会阻塞直到需要的对象返回。</p><p>如果在使用<code>await</code>时导致编译错误，请确保<code>await</code>在一个异步函数中使用。例如，如果想在<code>main()</code>函数中使用<code>await</code>，那么<code>main()</code>函数就必须使用<code>async</code>关键字标识。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future main() <span class="keyword">async</span> &#123;</span><br><span class="line">  checkVersion();</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;在 Main 函数中执行：版本是 <span class="subst">$&#123;await lookUpVersion()&#125;</span>&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="声明异步函数"><a href="#声明异步函数" class="headerlink" title="声明异步函数"></a>声明异步函数</h4><p>定义<strong>异步函数</strong>只需在普通方法上加上<code>async</code>关键字即可。<br>将关键字<code>async</code>添加到函数并让其返回一个<code>Future</code> 对象。假设有如下返回<code>String</code>对象的方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> lookUpVersion() =&gt; <span class="string">&#x27;1.0.0&#x27;</span>;</span><br></pre></td></tr></table></figure><p>将其改为异步函数，返回值是<code>Future</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">String</span>&gt; lookUpVersion() <span class="keyword">async</span> =&gt; <span class="string">&#x27;1.0.0&#x27;</span>;</span><br></pre></td></tr></table></figure><p>注意，函数体不需要使用<code>Future API</code>。如有必要，<code>Dart</code>会创建<code>Future</code>对象。<br>如果函数没有返回有效值，需要设置其返回类型为 <code>Future&lt;void&gt;</code></p><h4 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h4><p><code>Stream</code>也是用于接收异步事件数据，和<code>Future</code>不同的是，它可以接收多个异步操作的结果（成功或失败）。 也就是说，在执行异步任务时，可以通过多次触发成功或失败事件来传递结果数据或错误异常。<code>Stream</code>常用于会多次读取数据的异步任务场景，如网络内容下载、文件读写等。举个例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Stream.fromFutures([</span><br><span class="line">  <span class="comment">// 1秒后返回结果</span></span><br><span class="line">  Future.delayed(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds: <span class="number">1</span>), () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello 1&quot;</span>;</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="comment">// 抛出一个异常</span></span><br><span class="line">  Future.delayed(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds: <span class="number">2</span>),()&#123;</span><br><span class="line">    <span class="keyword">throw</span> AssertionError(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="comment">// 3秒后返回结果</span></span><br><span class="line">  Future.delayed(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds: <span class="number">3</span>), () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello 3&quot;</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">]).listen((data)&#123;</span><br><span class="line">   <span class="built_in">print</span>(data);</span><br><span class="line">&#125;, onError: (e)&#123;</span><br><span class="line">   <span class="built_in">print</span>(e.message);</span><br><span class="line">&#125;,onDone: ()&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码依次会输出：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello <span class="number">1</span></span><br><span class="line">Error</span><br><span class="line">hello <span class="number">3</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart语言 </tag>
            
            <tag> Flutter教程 </tag>
            
            <tag> Dart类 </tag>
            
            <tag> Dart异步 </tag>
            
            <tag> Dart Future </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 1-12】Flutter手把手教程Dart语言——什么是泛型和泛型的使用场景</title>
      <link href="dart-generic-1-12.html"/>
      <url>dart-generic-1-12.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>如果你查看数组的API文档，你会发现数组<code>List</code>的实际类型为<code>List&lt;E&gt;</code>。<code>&lt;&gt;</code> 符号表示数组是一个泛型（或参数化类型）通常使用一个字母来代表类型参数，比如E、T、S、K 和 V 等等。</p><h4 id="为什么使用泛型？"><a href="#为什么使用泛型？" class="headerlink" title="为什么使用泛型？"></a>为什么使用泛型？</h4><p>泛型常用于需要要求类型安全的情况，但是它对代码运行也有好处：</p><ul><li>适当地指定泛型可以更好地帮助代码生成。</li><li>使用泛型可以减少代码重复。</li></ul><p>比如你想声明一个只能包含<code>String</code>类型的数组，你可以将该数组声明为<code>List&lt;String&gt;</code>，这表示只能包含字符串类型的数组。这样的话就可以很容易避免因为在该数组放入非<code>String</code>类变量而导致的诸多问题，同时编译器以及其他阅读代码的人都可以很容易地发现并定位问题：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">names.addAll([<span class="string">&#x27;Seth&#x27;</span>, <span class="string">&#x27;Kathy&#x27;</span>, <span class="string">&#x27;Lars&#x27;</span>]);</span><br><span class="line">names.add(<span class="number">42</span>); <span class="comment">// 这样写就会报错</span></span><br><span class="line">``` </span><br><span class="line">另一个使用泛型的原因是可以减少重复代码。泛型可以让你在多个不同类型实现之间共享同一个接口声明，比如下面的例子中声明了一个类用于缓存对象的接口：</span><br><span class="line">``` dart</span><br><span class="line"><span class="comment">/// <span class="markdown">定义一个 抽象类</span></span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectCache</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span> getByKey(<span class="built_in">String</span> key);</span><br><span class="line">  <span class="keyword">void</span> setByKey(<span class="built_in">String</span> key, <span class="built_in">Object</span> value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不久后你可能又会想专门为<code>String</code>类对象做一个缓存，于是又有了专门为<code>String</code>做缓存的类：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">另外一个抽象类</span></span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StringCache</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> getByKey(<span class="built_in">String</span> key);</span><br><span class="line">  <span class="keyword">void</span> setByKey(<span class="built_in">String</span> key, <span class="built_in">String</span> value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果过段时间你又想为数字类型也创建一个类，那么就会有很多诸如此类的代码。<br>这时候可以考虑使用泛型来声明一个类，让不同类型的缓存实现该类做出不同的具体实现即可：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  T getByKey(<span class="built_in">String</span> key);</span><br><span class="line">  <span class="keyword">void</span> setByKey(<span class="built_in">String</span> key, T value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>T</code>是一个替代类型。其相当于类型占位符，在开发者调用该接口的时候会指定具体类型。</p><h4 id="使用集合字面量"><a href="#使用集合字面量" class="headerlink" title="使用集合字面量"></a>使用集合字面量</h4><p><code>List、Set</code>以及<code>Map</code>字面量也可以是参数化的。定义参数化的<code>List</code>只需在中括号前添加<code>&lt;type&gt;</code>；定义参数化的<code>Map</code>只需要在大括号前添加 <code>&lt;keyType, valueType&gt;</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = &lt;<span class="built_in">String</span>&gt;[<span class="string">&#x27;小芸&#x27;</span>, <span class="string">&#x27;小芳&#x27;</span>, <span class="string">&#x27;小民&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> uniqueNames = &lt;<span class="built_in">String</span>&gt;&#123;<span class="string">&#x27;小芸&#x27;</span>, <span class="string">&#x27;小芳&#x27;</span>, <span class="string">&#x27;小民&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> pages = &lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;&#123;</span><br><span class="line">  <span class="string">&#x27;index.html&#x27;</span>: <span class="string">&#x27;主页&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;robots.txt&#x27;</span>: <span class="string">&#x27;网页机器人提示&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;humans.txt&#x27;</span>: <span class="string">&#x27;我们是人类，不是机器&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="使用类型参数化的构造函数"><a href="#使用类型参数化的构造函数" class="headerlink" title="使用类型参数化的构造函数"></a>使用类型参数化的构造函数</h4><p>在调用构造方法时也可以使用泛型，只需在类名后用尖括号<code>&lt;...&gt;</code>将一个或多个类型包裹即可：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nameSet = <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt;.from(names);</span><br></pre></td></tr></table></figure><p>下面代码创建了一个键为<code>Int</code>类型，值为<code>View</code>类型的<code>Map</code>对象：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> views = <span class="built_in">Map</span>&lt;<span class="built_in">int</span>, View&gt;();</span><br></pre></td></tr></table></figure><h4 id="泛型集合以及它们所包含的类型"><a href="#泛型集合以及它们所包含的类型" class="headerlink" title="泛型集合以及它们所包含的类型"></a>泛型集合以及它们所包含的类型</h4><p>Dart的泛型类型是固化的，这意味着即便在运行时也会保持类型信息：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">names.addAll([<span class="string">&#x27;小芸&#x27;</span>, <span class="string">&#x27;小芳&#x27;</span>, <span class="string">&#x27;小民&#x27;</span>]);</span><br><span class="line"><span class="built_in">print</span>(names <span class="keyword">is</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="限制参数化类型"><a href="#限制参数化类型" class="headerlink" title="限制参数化类型"></a>限制参数化类型</h4><p>有时使用泛型的时候可能会想限制泛型的类型范围，这时候可以使用<code>extends</code>关键字：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SomeBaseClass</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 具体实现……</span></span><br><span class="line">  <span class="built_in">String</span> toString() =&gt; <span class="string">&quot;&#x27;Foo&lt;<span class="subst">$T</span>&gt;&#x27; 的实例&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Extender</span> <span class="keyword">extends</span> <span class="title">SomeBaseClass</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>这时候就可以使用<code>SomeBaseClass</code>或者它的子类来作为泛型参数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someBaseClassFoo = Foo&lt;SomeBaseClass&gt;();</span><br><span class="line"><span class="keyword">var</span> extenderFoo = Foo&lt;Extender&gt;();</span><br></pre></td></tr></table></figure><p>这时候也可以指定无参数的泛型，这时无参数泛型的类型则为 <code>Foo&lt;SomeBaseClass&gt;</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = Foo();</span><br><span class="line"><span class="built_in">print</span>(foo); <span class="comment">// &#x27;Foo&lt;SomeBaseClass&gt;&#x27; 的例   </span></span><br></pre></td></tr></table></figure><p>将非<code>SomeBaseClass</code>的类型作为泛型参数则会导致编译错误：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">这样写是会报错的</span></span></span><br><span class="line"><span class="keyword">var</span> foo = Foo&lt;<span class="built_in">Object</span>&gt;(); </span><br></pre></td></tr></table></figure><h4 id="使用泛型方法"><a href="#使用泛型方法" class="headerlink" title="使用泛型方法"></a>使用泛型方法</h4><p>起初<code>Dart</code>只支持在类的声明时指定泛型，现在同样也可以在方法上使用泛型，称之为<code>泛型方法</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T first&lt;T&gt;(<span class="built_in">List</span>&lt;T&gt; ts) &#123;</span><br><span class="line">  <span class="comment">// 处理一些初始化工作或错误检测……</span></span><br><span class="line">  T tmp = ts[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// 处理一些额外的检查……</span></span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法 <code>first&lt;T&gt;</code> 的泛型<code>T</code>可以在如下地方使用：</p><ul><li>函数的返回值类型 <code>T</code>。</li><li>参数的类型 <code>List&lt;T&gt;</code>。</li><li>局部变量的类型 <code>T tmp</code>。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart语言 </tag>
            
            <tag> Dart运算符 </tag>
            
            <tag> Flutter教程 </tag>
            
            <tag> Dart类 </tag>
            
            <tag> Dart Class </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 1-11】Flutter手把手教程Dart语言——类、类的的成员变量和方法、类的构造函数</title>
      <link href="dart-class-1-11.html"/>
      <url>dart-class-1-11.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>Dart是一种面向对象的语言，所有对象都是一个类的实例，而所有的类都继承自<code>Object</code>类。每个除了<code>Object</code>类之外的类都只有一个超类，一个类的代码可以在其它多个类继承中重复使用。</p><h4 id="类的实例变量"><a href="#类的实例变量" class="headerlink" title="类的实例变量"></a>类的实例变量</h4><p>下面是声明实例变量的示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">double</span> x; <span class="comment">// 声明 double 变量 x 并初始化为 null。</span></span><br><span class="line">  <span class="built_in">double</span> y; <span class="comment">// 声明 double 变量 y 并初始化为 null</span></span><br><span class="line">  <span class="built_in">double</span> z = <span class="number">0</span>; <span class="comment">// 声明 double 变量 z 并初始化为 0。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有未初始化的实例变量其值均为<code>null</code>。</p><p>所有实例变量均会隐式地声明一个<code>Getter</code> 方法，非<code>final</code>类型的实例变量还会隐式地声明一个<code>Setter</code>方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">double</span> x;</span><br><span class="line">  <span class="built_in">double</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> point = Point();</span><br><span class="line">  point.x = <span class="number">4</span>; <span class="comment">// 使用 x 的 Setter 方法。</span></span><br><span class="line">  <span class="keyword">assert</span>(point.x == <span class="number">4</span>); <span class="comment">// 使用 x 的 Getter 方法。</span></span><br><span class="line">  <span class="keyword">assert</span>(point.y == <span class="keyword">null</span>); <span class="comment">// 默认值为 null。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你在声明一个实例变量的时候就将其初始化（而不是在构造函数或其它方法中），那么该实例变量的值就会在对象实例创建的时候被设置，该过程会在构造函数以及它的初始化器列表执行前。</p><h5 id="访问类的成员"><a href="#访问类的成员" class="headerlink" title="访问类的成员"></a>访问类的成员</h5><p>对象的成员由函数和数据（即方法和实例变量）组成。方法的调用要通过对象来完成，这种方式可以访问对象的函数和数据。<br>使用<code>.</code>来访问对象的实例变量或方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = Point(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 获取 y 值</span></span><br><span class="line"><span class="keyword">assert</span>(p.y == <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 调用变量 p 的 distanceTo() 方法。</span></span><br><span class="line"><span class="built_in">double</span> distance = p.distanceTo(Point(<span class="number">4</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure><p>使用 <code>?.</code> 代替<code>.</code>可以避免因为左边表达式为<code>null</code> 而导致的问题：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If p is non-null, set a variable equal to its y value.</span></span><br><span class="line"><span class="keyword">var</span> a = p?.y;</span><br></pre></td></tr></table></figure><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>方法是对象提供行为的函数。</p><p>对象的实例方法可以访问实例变量和<code>this</code>。下面的<code>distanceTo()</code>方法就是一个实例方法的例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:math&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">double</span> x, y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">double</span> distanceTo(Point other) &#123;</span><br><span class="line">    <span class="keyword">var</span> dx = x - other.x;</span><br><span class="line">    <span class="keyword">var</span> dy = y - other.y;</span><br><span class="line">    <span class="keyword">return</span> sqrt(dx * dx + dy * dy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="重写类成员"><a href="#重写类成员" class="headerlink" title="重写类成员"></a>重写类成员</h5><p>子类可以重写父类的实例方法（包括操作符）、 <code>Getter</code> 以及 <code>Setter</code> 方法。你可以使用 <code>@override</code>注解来表示你重写了一个成员：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartTelevision</span> <span class="keyword">extends</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;...&#125;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="noSuchMethod-方法"><a href="#noSuchMethod-方法" class="headerlink" title="noSuchMethod 方法"></a>noSuchMethod 方法</h5><p>如果调用了对象中不存在的方法或实例变量将会触发<code>noSuchMethod</code> 方法，你可以重写<code>noSuchMethod</code>方法来追踪和记录这一行为：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 除非你重写 noSuchMethod，否则调用一个不存在的成员会导致 NoSuchMethodError。</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> noSuchMethod(Invocation invocation) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;你尝试使用一个不存在的成员：&#x27;</span> + <span class="string">&#x27;<span class="subst">$&#123;invocation.memberName&#125;</span>&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你不能调用一个未实现的方法除非满足下面其中的一个条件：</p><ul><li>接收方是静态的<code>dynamic</code> 类型。</li><li>接收方具有静态类型，定义了未实现的方法，并且接收方的动态类型实现了<code>noSuchMethod</code>方法且具体的实现与<code>Object</code>中的不同。</li></ul><h4 id="类的静态变量和静态方法"><a href="#类的静态变量和静态方法" class="headerlink" title="类的静态变量和静态方法"></a>类的静态变量和静态方法</h4><p>使用关键字<code>static</code>可以声明类变量或类方法。</p><h5 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h5><p>静态变量（即类变量）常用于声明类范围内所属的状态变量和常量：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> initialCapacity = <span class="number">16</span>;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(Queue.initialCapacity == <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态变量在其首次被使用的时候才被初始化。</p><h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><p>静态方法（即类方法）不能被一个类的实例访问，同样地，静态方法内也不可以使用关键字<code>this</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:math&#x27;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">double</span> x, y;</span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">double</span> distanceBetween(Point a, Point b) &#123;</span><br><span class="line">    <span class="keyword">var</span> dx = a.x - b.x;</span><br><span class="line">    <span class="keyword">var</span> dy = a.y - b.y;</span><br><span class="line">    <span class="keyword">return</span> sqrt(dx * dx + dy * dy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> a = Point(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">var</span> b = Point(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">var</span> distance = Point.distanceBetween(a, b);</span><br><span class="line">  <span class="keyword">assert</span>(<span class="number">2.8</span> &lt; distance &amp;&amp; distance &lt; <span class="number">2.9</span>);</span><br><span class="line">  <span class="built_in">print</span>(distance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用构造函数构建对象"><a href="#使用构造函数构建对象" class="headerlink" title="使用构造函数构建对象"></a>使用构造函数构建对象</h4><p>可以使用构造函数来创建一个对象。构造函数的命名方式可以为类名或类名<code>.</code>标识符的形式。例如下述代码分别使用<code>Point()</code>和<code>Point.fromJson()</code>两种构造器来创建<code>Point</code>对象：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = Point(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = Point.fromJson(&#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure><p>以下代码具有相同的效果，构造函数名前面的的<code>new</code>关键字是可选的：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Point.fromJson(&#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure><p>一些类提供了常量构造函数。使用常量构造函数，在构造函数名之前加 <code>const</code>关键字，来创建编译时常量时：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">const</span> ImmutablePoint(<span class="number">2</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>两个使用相同构造函数相同参数值构造的编译时常量是同一个对象：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">const</span> ImmutablePoint(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">const</span> ImmutablePoint(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(identical(a, b)); <span class="comment">// 它们是同一个实例 (They are the same instance!)</span></span><br></pre></td></tr></table></figure><p>根据使用常量上下文的场景，你可以省略掉构造函数或字面量前的<code>const</code> 关键字。例如下面的例子中我们创建了一个常量<code>Map</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里有很多 const 关键字</span></span><br><span class="line"><span class="keyword">const</span> pointAndLine = <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="string">&#x27;point&#x27;</span>: <span class="keyword">const</span> [<span class="keyword">const</span> ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>)],</span><br><span class="line">  <span class="string">&#x27;line&#x27;</span>: <span class="keyword">const</span> [<span class="keyword">const</span> ImmutablePoint(<span class="number">1</span>, <span class="number">10</span>), <span class="keyword">const</span> ImmutablePoint(<span class="number">-2</span>, <span class="number">11</span>)],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据上下文，你可以只保留第一个<code>const</code>关键字，其余的全部省略：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只需要一个 const 关键字，其它的则会隐式地根据上下文进行关联。</span></span><br><span class="line"><span class="keyword">const</span> pointAndLine = &#123;</span><br><span class="line">  <span class="string">&#x27;point&#x27;</span>: [ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>)],</span><br><span class="line">  <span class="string">&#x27;line&#x27;</span>: [ImmutablePoint(<span class="number">1</span>, <span class="number">10</span>), ImmutablePoint(<span class="number">-2</span>, <span class="number">11</span>)],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是如果无法根据上下文判断是否可以省略<code>const</code>，则不能省略掉 <code>const</code>关键字，否则将会创建一个<strong>非</strong>常量对象 例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">const</span> ImmutablePoint(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 创建一个常量 (Creates a constant)</span></span><br><span class="line"><span class="keyword">var</span> b = ImmutablePoint(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 不会创建一个常量</span></span><br><span class="line"><span class="keyword">assert</span>(!identical(a, b)); <span class="comment">// 这两变量并不相同 </span></span><br></pre></td></tr></table></figure><h4 id="获取对象的类型"><a href="#获取对象的类型" class="headerlink" title="获取对象的类型"></a>获取对象的类型</h4><p>可以使用<code>Object</code>对象的<code>runtimeType</code>属性在运行时获取一个对象的类型，该对象类型是<code>Type</code>的实例。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> = Point(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The type of a is <span class="subst">$&#123;a.runtimeType&#125;</span>&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>声明一个与类名一样的函数即可声明一个构造函数（对于命名式构造函数 还可以添加额外的标识符)。大部分的构造函数形式是生成式构造函数，其用于创建一个类的实例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">double</span> x, y;</span><br><span class="line">  Point(<span class="built_in">double</span> x, <span class="built_in">double</span> y) &#123;</span><br><span class="line">    <span class="comment">// 还会有更好的方式来实现此逻辑，敬请期待。</span></span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>this</code> 关键字引用当前实例。<br>对于大多数编程语言来说在构造函数中为实例变量赋值的过程都是类似的，而<code>Dart</code>则提供了一种特殊的语法糖来简化该步骤：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">double</span> x, y;</span><br><span class="line">  <span class="comment">// 在构造函数体执行前用于设置 x 和 y 的语法糖。</span></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h5><p>如果你没有声明构造函数，那么<code>Dart</code>会自动生成一个无参数的构造函数并且该构造函数会调用其父类的无参数构造方法。</p><h5 id="构造函数不被继承"><a href="#构造函数不被继承" class="headerlink" title="构造函数不被继承"></a>构造函数不被继承</h5><p>子类不会继承父类的构造函数，如果子类没有声明构造函数，那么只会有一个默认无参数的构造函数。</p><h5 id="命名式构造函数"><a href="#命名式构造函数" class="headerlink" title="命名式构造函数"></a>命名式构造函数</h5><p>可以为一个类声明多个命名式构造函数来表达更明确的意图：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">double</span> x, y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 命名式构造函数</span></span><br><span class="line">  Point.origin() &#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数是不能被继承的，这将意味着子类不能继承父类的命名式构造函数，如果你想在子类中提供一个与父类命名构造函数名字一样的命名构造函数，则需要在子类中显式地声明。</p><h5 id="调用父类非默认构造函数"><a href="#调用父类非默认构造函数" class="headerlink" title="调用父类非默认构造函数"></a>调用父类非默认构造函数</h5><p>默认情况下，子类的构造函数会调用父类的匿名无参数构造方法，并且该调用会在子类构造函数的函数体代码执行前，如果子类构造函数还有一个初始化列表，那么该初始化列表会在调用父类的该构造函数之前被执行，总的来说，这三者的调用顺序如下：</p><ol><li>初始化列表</li><li>父类的无参数构造函数</li><li>当前类的构造函数</li></ol><p>如果父类没有匿名无参数构造函数，那么子类必须调用父类的其中一个构造函数，为子类的构造函数指定一个父类的构造函数只需在构造函数体前使用<code>:</code>指定。</p><p>因为参数会在子类构造函数被执行前传递给父类的构造函数，因此该参数也可以是一个表达式，比如一个函数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  Employee() : <span class="keyword">super</span>.fromJson(defaultData);</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h5><p>除了调用父类构造函数之外，还可以在构造函数体执行之前初始化实例变量。每个实例变量之间使用逗号分隔。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用初始化列表在构造函数体执行前设置实例变量。</span></span><br><span class="line">Point.fromJson(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">double</span>&gt; json)</span><br><span class="line">    : x = json[<span class="string">&#x27;x&#x27;</span>],</span><br><span class="line">      y = json[<span class="string">&#x27;y&#x27;</span>] &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;In Point.fromJson(): (<span class="subst">$x</span>, <span class="subst">$y</span>)&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在开发模式下，你可以在初始化列表中使用<code>assert</code>来验证输入数据：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Point.withAssert(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y) : <span class="keyword">assert</span>(x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;In Point.withAssert(): (<span class="subst">$x</span>, <span class="subst">$y</span>)&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="重定向构造函数"><a href="#重定向构造函数" class="headerlink" title="重定向构造函数"></a>重定向构造函数</h5><p>有时候类中的构造函数会调用类中其它的构造函数，该重定向构造函数没有函数体，只需在函数签名后使用<code>:</code>指定需要重定向到的其它构造函数即可：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">double</span> x, y;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 该类的主构造函数。</span></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 委托实现给主构造函数。</span></span><br><span class="line">  Point.alongXAxis(<span class="built_in">double</span> x) : <span class="keyword">this</span>(x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="常量构造函数"><a href="#常量构造函数" class="headerlink" title="常量构造函数"></a>常量构造函数</h5><p>如果类生成的对象都是不会变的，那么可以在生成这些对象时就将其变为编译时常量。你可以在类的构造函数前加上<code>const</code>关键字并确保所有实例变量均为<code>final</code>来实现该功能。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImmutablePoint</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> ImmutablePoint origin =</span><br><span class="line">      <span class="keyword">const</span> ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> x, y;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ImmutablePoint(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量构造函数创建的实例并不总是常量。</p><h5 id="工厂构造函数"><a href="#工厂构造函数" class="headerlink" title="工厂构造函数"></a>工厂构造函数</h5><p>使用<code>factory</code>关键字标识类的构造函数将会令该构造函数变为工厂构造函数，这将意味着使用该构造函数构造类的实例时并非总是会返回新的实例对象。例如，工厂构造函数可能会从缓存中返回一个实例，或者返回一个子类型的实例。</p><p>在如下的示例中，<code>Logger</code>的工厂构造函数从缓存中返回对象，和 <code>Logger.fromJson</code>工厂构造函数从<code>JSON</code>对象中初始化一个最终变量。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">bool</span> mute = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// _cache 变量是库私有的，因为在其名字前面有下划线。</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Logger&gt; _cache =</span><br><span class="line">      &lt;<span class="built_in">String</span>, Logger&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> Logger(<span class="built_in">String</span> name) &#123;</span><br><span class="line">    <span class="keyword">return</span> _cache.putIfAbsent(</span><br><span class="line">        name, () =&gt; Logger._internal(name));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> Logger.fromJson(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; json) &#123;</span><br><span class="line">    <span class="keyword">return</span> Logger(json[<span class="string">&#x27;name&#x27;</span>].toString());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Logger._internal(<span class="keyword">this</span>.name);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> log(<span class="built_in">String</span> msg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mute) <span class="built_in">print</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂构造函的调用方式与其他构造函数一样：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logger = Logger(<span class="string">&#x27;UI&#x27;</span>);</span><br><span class="line">logger.log(<span class="string">&#x27;Button clicked&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logMap = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;UI&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> loggerJson = Logger.fromJson(logMap);</span><br></pre></td></tr></table></figure><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>使用关键字<code>abstract</code> 标识类可以让该类成为抽象类，抽象类将无法被实例化。抽象类常用于声明接口方法、有时也会有具体的方法实现。如果想让抽象类同时可被实例化，可以为其定义工厂构造函数。</p><p>抽象类常常会包含抽象方法。下面是一个声明具有抽象方法的抽象类示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该类被声明为抽象的，因此它不能被实例化。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractContainer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义构造函数、字段、方法等……</span></span><br><span class="line">  <span class="keyword">void</span> updateChildren(); <span class="comment">// 抽象方法。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="隐式接口"><a href="#隐式接口" class="headerlink" title="隐式接口"></a>隐式接口</h4><p>每一个类都隐式地定义了一个接口并实现了该接口，这个接口包含所有这个类的实例成员以及这个类所实现的其它接口。如果想要创建一个<code>A</code>类支持调用<code>B</code>类的API且不想继承<code>B</code>类，则可以实现<code>B</code>类的接口。</p><p>一个类可以通过关键字<code>implements</code>来实现一个或多个接口并实现每个接口定义的 API：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person 类的隐式接口中包含 greet() 方法。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// _name 变量同样包含在接口中，但它只是库内可见的。</span></span><br><span class="line">  <span class="keyword">final</span> _name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造函数不在接口中。</span></span><br><span class="line">  Person(<span class="keyword">this</span>._name);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// greet() 方法在接口中。</span></span><br><span class="line">  <span class="built_in">String</span> greet(<span class="built_in">String</span> who) =&gt; <span class="string">&#x27;你好，<span class="subst">$who</span>。我是<span class="subst">$_name</span>。&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person 接口的一个实现。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Impostor</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> _name =&gt; <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> greet(<span class="built_in">String</span> who) =&gt; <span class="string">&#x27;你好<span class="subst">$who</span>。你知道我是谁吗？&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span> greetBob(Person person) =&gt; person.greet(<span class="string">&#x27;小芳&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(greetBob(Person(<span class="string">&#x27;小芸&#x27;</span>)));</span><br><span class="line">  <span class="built_in">print</span>(greetBob(Impostor()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要实现多个类接口，可以使用逗号分割每个接口类：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> <span class="keyword">implements</span> <span class="title">Comparable</span>, <span class="title">Location</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扩展一个类"><a href="#扩展一个类" class="headerlink" title="扩展一个类"></a>扩展一个类</h4><p>使用<code>extends</code>关键字来创建一个子类，并可使用<code>super</code>关键字引用一个父类：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;</span><br><span class="line">    _illuminateDisplay();</span><br><span class="line">    _activateIrSensor();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartTelevision</span> <span class="keyword">extends</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;</span><br><span class="line">    <span class="keyword">super</span>.turnOn();</span><br><span class="line">    _bootNetworkInterface();</span><br><span class="line">    _initializeMemory();</span><br><span class="line">    _upgradeApps();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-Mixin-为类添加功能"><a href="#使用-Mixin-为类添加功能" class="headerlink" title="使用 Mixin 为类添加功能"></a>使用 Mixin 为类添加功能</h4><p><code>Mixin</code>是一种在多重继承中复用某个类中代码的方法模式。<br>使用<code>with</code>关键字并在其后跟上<code>Mixin</code>类的名字来使用<code>Mixin</code>模式：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Musician</span> <span class="keyword">extends</span> <span class="title">Performer</span> <span class="title">with</span> <span class="title">Musical</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Maestro</span> <span class="keyword">extends</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">Musical</span>, <span class="title">Aggressive</span>, <span class="title">Demented</span> </span>&#123;</span><br><span class="line">  Maestro(<span class="built_in">String</span> maestroName) &#123;</span><br><span class="line">    name = maestroName;</span><br><span class="line">    canConduct = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个类继承自<code>Object</code>并且不为该类定义构造函数，这个类就是 <code>Mixin</code>类，除非你想让该类与普通的类一样可以被正常地使用，否则可以使用关键字<code>mixin</code>替代<code>class</code>让其成为一个单纯的<code>Mixin</code>类：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixin</span> Musical &#123;</span><br><span class="line">  <span class="built_in">bool</span> canPlayPiano = <span class="keyword">false</span>;</span><br><span class="line">  <span class="built_in">bool</span> canCompose = <span class="keyword">false</span>;</span><br><span class="line">  <span class="built_in">bool</span> canConduct = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> entertainMe() &#123;</span><br><span class="line">    <span class="keyword">if</span> (canPlayPiano) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;Playing piano&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (canConduct) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;Waving hands&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;Humming to self&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用关键字<code>on</code>来指定哪些类可以使用该<code>Mixin</code>类，比如有 <code>Mixin</code>类 <code>A</code>，但是<code>A</code>只能被<code>B</code>类使用，则可以这样定义 `A：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Musician</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">mixin</span> MusicalPerformer <span class="keyword">on</span> Musician &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingerDancer</span> <span class="keyword">extends</span> <span class="title">Musician</span> <span class="title">with</span> <span class="title">MusicalPerformer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Extension-方法"><a href="#Extension-方法" class="headerlink" title="Extension 方法"></a>Extension 方法</h4><p>Dart 2.7 中引入的<code>Extension</code>方法是向现有库添加功能的一种方式。<br>这里是一个在 String 中使用 <code>extension </code>方法的样例，我们取名为 <code>parseInt()</code>，它在 <code>string_apis.dart</code> 中定义：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> NumberParsing <span class="keyword">on</span> <span class="built_in">String</span> &#123;</span><br><span class="line">  <span class="built_in">int</span> parseInt() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>.parse(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">double</span> parseDouble() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">double</span>.parse(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用<code>string_apis.dart</code>里面的<code>parseInt()</code>方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;string_apis.dart&#x27;</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;42&#x27;</span>.padLeft(<span class="number">5</span>)); <span class="comment">// Use a String method.</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;42&#x27;</span>.parseInt()); <span class="comment">// Use an extension method.</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart语言 </tag>
            
            <tag> Dart运算符 </tag>
            
            <tag> Flutter教程 </tag>
            
            <tag> Dart类 </tag>
            
            <tag> Dart Class </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免费送书啦！细数Github大神们的开源书籍！[二]</title>
      <link href="tips-github-free-books-4.html"/>
      <url>tips-github-free-books-4.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h3 id="计算机软件设计"><a href="#计算机软件设计" class="headerlink" title="计算机软件设计"></a>计算机软件设计</h3><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_3.jpeg" /></p><p align="center">《软件设计的哲学》</p><blockquote><p>《软件设计的哲学》斯坦福教授、Tcl 语言发明者 John Ousterhout 的著作《A Philosophy of Software Design》，自出版以来，好评如潮。按照 IT 图书出版的惯例，如果冠名为“实践”，书中内容关注的是某项技术的细节和技巧；冠名为“艺术”，内容可能是记录一件优秀作品的设计过程和经验；而冠名为“哲学”，则是一些通用的原则和方法论，这些原则方法论串起来，能够形成一个体系。正如”知行合一”、“世界是由原子构成的”、“我思故我在”，这些耳熟能详的句子能够一定程度上代表背后的人物和思想。用一句话概括《A Philosophy of Software Design》，软件设计的核心在于降低复杂性。<br><a href="https://github.com/gdut-yy/A-Philosophy-of-Software-Design-zh">领取地址</a></p></blockquote><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_17.jpeg" /></p><p align="center">《设计数据密集型应用》</p><blockquote><p>《设计数据密集型应用》现今，尤其是在互联网领域，大多数应用都属于数据密集型应用。本书从底层数据结构到顶层架构设计，将数据系统设计中的精髓娓娓道来。其中的宝贵经验无论是对架构师，DBA、还是后端工程师、甚至产品经理都会有帮助。这是一本理论结合实践的书，书中很多问题，译者在实际场景中都曾遇到过，读来让人击节扼腕。如果能早点读到这本书，该少走多少弯路啊！这也是一本深入浅出的书，讲述概念的来龙去脉而不是卖弄定义，介绍事物发展演化历程而不是事实堆砌，将复杂的概念讲述的浅显易懂，但又直击本质不失深度。每章最后的引用质量非常好，是深入学习各个主题的绝佳索引。<br><a href="https://github.com/Vonng/ddia">领取地址</a></p></blockquote><p align="center">《操作系统的基本原理与简单实现》</p><blockquote><p>《操作系统的基本原理与简单实现》<br>早期开放开源的UNIX操作系统和MIT教授 Frans Kaashoek 等基于UNIX v6设计的xv6操作系统给了我们启发：对一个计算机专业的本科生而言，设计实现一个操作系统有挑战但是可行！但x86相对封闭&amp;复杂和有一定历史包袱的CPU硬件接口给OS学习带来了一定的挑战。1980年前后，UC Berkeley的Dave Patterson主导了Berkeley RISC项目并设计了其第一代的处理器RISC I，并在2014年发展到了开放&amp;开源的第五代指令集架构RISC-V。本书想进行这样的教学尝试，以操作系统基本原理为教学引导，以简洁的RISC-V CPU为底层硬件基础，设计并实现一个微型但全面的“麻雀”操作系统—ucore。期望能够采用简化的计算机硬件为基础，以操作系统的基本概念和核心原理为实践指导，逐步解析操作系统各种知识点和对应的实验，做到有“理”可循和有“码”可查，最终让读者了解和掌握操作系统的原理、设计与实现。<br><a href="https://github.com/chyyuu/simple_os_book">领取地址</a></p></blockquote><h3 id="RTC"><a href="#RTC" class="headerlink" title="RTC"></a>RTC</h3><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_7.jpeg" /></p><p align="center">《Real-Time Communication with WebRTC》</p><blockquote><p>《Real-Time Communication with WebRTC》<br>在浏览器中提供丰富的音频和视频实时通信和点对点数据交换，不需要私有插件。这个简明的实践指南向您展示了如何使用新兴的Web实时通信(WebRTC)技术来构建一个浏览器到浏览器的应用程序。<br>作者通过实例学习的方法非常适合那些希望理解实时通信的 web 程序员，以及不熟悉 HTML5 和基于 javascript 的客户端-服务器 web 编程的电信架构师。<br><a href="https://github.com/a-wing/webrtc-book-cn">领取地址</a></p></blockquote><p align="center">《SDN网络指南》</p><blockquote><p>SDN（Software Defined Networking）作为当前最重要的热门技术之一，目前已经普遍得到大家的共识。有关SDN的资料和书籍非常丰富，但入门和学习SDN依然是非常困难。本书整理了SDN实践中的一些基本理论和实践案例心得，希望能给大家带来启发，也欢迎大家关注和贡献。<br><a href="https://github.com/feiskyer/sdn-handbook">领取地址</a></p></blockquote><h3 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h3><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_17.jpeg" /></p><p align="center">《Prometheus 操作指南》</p><blockquote><p>这里假定你已经对Linux系统以及Docker技术有一定的基本认识，也可能使用过像Java，Golang这样的编程语言，在本书中我们不会事无巨细的讲述所有事。<br><a href="https://github.com/yunlzheng/prometheus-book">领取地址</a></p></blockquote><h4 id="英文书籍"><a href="#英文书籍" class="headerlink" title="英文书籍"></a>英文书籍</h4><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_12.png" /></p><p align="center">《Python Data Science Handbook》</p><blockquote><p>英文原版《Python Data Science Handbook》，该书对于希望或已经从事数据科学相关工作的 Python 工程师而言是重要的学习手册。<br><a href="https://github.com/jakevdp/PythonDataScienceHandbook">领取地址</a></p></blockquote><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_13.png" /></p><p align="center">《You-Dont-Know-JS》</p>  <blockquote><p>深入探讨 JavaScript 语言核心机制的书籍，适用于深入学习 JS。<br><a href="https://github.com/getify/You-Dont-Know-JS">领取地址</a></p></blockquote><h4 id="获取更多"><a href="#获取更多" class="headerlink" title="获取更多"></a>获取更多</h4><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_10.jpg" /></p><p align="center">《JAVA编程思想 第五版》</p><blockquote><p>本书原作者为 [美] Bruce Eckel，即《Java 编程思想》的作者。<br>本书是事实上的 《Java 编程思想》第五版。《Java 编程思想》第四版基于 JAVA 5 版本；《On Java 8》 基于 JAVA 8 版本。<br>关注公众号:【fulade_me】<br>回复关键字：<strong>Java5</strong></p></blockquote><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_11.jpg" /></p><p align="center">《渗透测试实战第三版》</p><blockquote><p>这本书是 《The Hacker Playbook》 的第三版，通常我们也说它是红队版。因为本书是以红蓝对抗中红队的视角来撰写的。<br>关注公众号:【fulade_me】<br>回复关键字：<strong>Hacker</strong></p></blockquote><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_14.png" /></p><p align="center">《动手学深度学习》</p><blockquote><p>本开源项目代表了我们的一种尝试：我们将教给读者概念、背景知识和代码；我们将在同一个地方阐述剖析问题所需的批判性思维、解决问题所需的数学知识，以及实现解决方案所需的工程技能。<br>关注公众号:【fulade_me】<br>回复关键字：<strong>深度学习</strong></p></blockquote><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 1-10】Flutter手把手教程Dart语言——运算符</title>
      <link href="dart-operator-1-10.html"/>
      <url>dart-operator-1-10.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。Dart语言内置了丰富的运算符，并提供了以下类型的运算符：<strong>算术运算符、关系运算符、类型判断运算符、赋值运算符、逻辑运算符、按位和移位运算符、条件表达式、级联运算符以及其他运算符</strong>。</p><h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h4><table><thead><tr><th>算数运算符</th><th>描述</th></tr></thead><tbody><tr><td>+</td><td>加</td></tr><tr><td>-</td><td>减</td></tr><tr><td>- 表达式</td><td>一元负, 也可以作为反转（反转表达式的符号）</td></tr><tr><td>*</td><td>乘</td></tr><tr><td>/</td><td>除</td></tr><tr><td>~/</td><td>除并取整</td></tr><tr><td>%</td><td>取模</td></tr><tr><td>示例：</td><td></td></tr></tbody></table><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>(<span class="number">2</span> + <span class="number">3</span> == <span class="number">5</span>);</span><br><span class="line"><span class="keyword">assert</span>(<span class="number">2</span> - <span class="number">3</span> == <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">assert</span>(<span class="number">2</span> * <span class="number">3</span> == <span class="number">6</span>);</span><br><span class="line"><span class="keyword">assert</span>(<span class="number">5</span> / <span class="number">2</span> == <span class="number">2.5</span>); <span class="comment">// 结果是一个浮点数</span></span><br><span class="line"><span class="keyword">assert</span>(<span class="number">5</span> ~/ <span class="number">2</span> == <span class="number">2</span>); <span class="comment">// 结果是一个整数</span></span><br><span class="line"><span class="keyword">assert</span>(<span class="number">5</span> % <span class="number">2</span> == <span class="number">1</span>); <span class="comment">// 取余</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(<span class="string">&#x27;5/2 = <span class="subst">$&#123;<span class="number">5</span> ~/ <span class="number">2</span>&#125;</span> r <span class="subst">$&#123;<span class="number">5</span> % <span class="number">2</span>&#125;</span>&#x27;</span> == <span class="string">&#x27;5/2 = 2 r 1&#x27;</span>);</span><br></pre></td></tr></table></figure><p>Dart 还支持自增自减运算符：</p><table><thead><tr><th>自增自减运算符</th><th>描述</th></tr></thead><tbody><tr><td>++ var</td><td>var = var + 1 (表达式的值为 var + 1)</td></tr><tr><td>var ++</td><td>var = var + 1 (表达式的值为 var)</td></tr><tr><td>– var</td><td>var = var – 1 (表达式的值为 var – 1)</td></tr><tr><td>var –</td><td>var = var – 1 (表达式的值为 var)</td></tr><tr><td>示例：</td><td></td></tr></tbody></table><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line">b = ++a; <span class="comment">// 在 b 赋值前将 a 增加 1。</span></span><br><span class="line"><span class="keyword">assert</span>(a == b); <span class="comment">// 1 == 1</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line">b = a++; <span class="comment">// 在 b 赋值后将 a 增加 1。</span></span><br><span class="line"><span class="keyword">assert</span>(a != b); <span class="comment">// 1 != 0</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line">b = --a; <span class="comment">// 在 b 赋值前将 a 减少 1。</span></span><br><span class="line"><span class="keyword">assert</span>(a == b); <span class="comment">// -1 == -1</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line">b = a--; <span class="comment">// 在 b 赋值后将 a 减少 1。</span></span><br><span class="line"><span class="keyword">assert</span>(a != b); <span class="comment">// -1 != 0</span></span><br></pre></td></tr></table></figure><h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><table><thead><tr><th>关系运算符</th><th>描述</th></tr></thead><tbody><tr><td>==</td><td>相等</td></tr><tr><td>!=</td><td>不等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>要判断两个对象 x 和 y 是否表示相同的事物使用 <code>==</code> 即可。（在极少数情况下，可能需要使用 <code>identical()</code> 函数来确定两个对象是否完全相同）。</td><td></td></tr><tr><td>下面是 <code>==</code> 运算符的一些规则：</td><td></td></tr></tbody></table><ol><li><p>假设有变量 <code>x</code> 和 <code>y</code>，且 <code>x</code> 和 <code>y</code> 至少有一个为 <code>null</code>，则当且仅当 <code>x</code> 和 <code>y</code> 均为 <code>null</code> 时 <code>x == y</code> 才会返回 <code>true</code>，否则只有一个为 <code>null</code> 则返回 <code>false</code>。</p></li><li><p><code>x.==(y)</code> 将会返回值，这里不管有没有<code>y</code>，即 <code>y</code> 是可选的。也就是说 <code>==</code> 其实是 <code>x</code> 中的一个方法，并且可以被重写。</p></li></ol><p>下面的代码给出了每一种关系运算符的示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>(<span class="number">2</span> == <span class="number">2</span>);</span><br><span class="line"><span class="keyword">assert</span>(<span class="number">2</span> != <span class="number">3</span>);</span><br><span class="line"><span class="keyword">assert</span>(<span class="number">3</span> &gt; <span class="number">2</span>);</span><br><span class="line"><span class="keyword">assert</span>(<span class="number">2</span> &lt; <span class="number">3</span>);</span><br><span class="line"><span class="keyword">assert</span>(<span class="number">3</span> &gt;= <span class="number">3</span>);</span><br><span class="line"><span class="keyword">assert</span>(<span class="number">2</span> &lt;= <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h4 id="类型判断运算符"><a href="#类型判断运算符" class="headerlink" title="类型判断运算符"></a>类型判断运算符</h4><p><code>as</code>、<code>is</code>、<code>is!</code> 运算符是在运行时判断对象类型的运算符。<br>|  类型判断运算符   | 描述  |<br>|  —-  | —-  |<br>|as|类型转换（也用作指定类前缀)）|<br>|is    |如果对象是指定类型则返回 true|<br>|is! |如果对象是指定类型则返回 false|</p><p>当且仅当 obj对象 实现了 <code>T</code> 的接口，obj对象 <code>is T</code> 才是 <code>true</code>。例如 obj对象 <code>is Object</code> 总为 <code>true</code>，因为所有类都是 <code>Object</code> 的子类。</p><p>仅当你确定这个对象是该类型的时候，你才可以使用 <code>as</code> 操作符可以把对象转换为特定的类型。例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(emp <span class="keyword">as</span> Person).firstName = <span class="string">&#x27;Bob&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果你不确定这个对象类型是不是 <code>T</code>，请在转型前使用 <code>is T</code> 检查类型。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (emp <span class="keyword">is</span> Person) &#123;</span><br><span class="line">  <span class="comment">// 类型检查</span></span><br><span class="line">  emp.firstName = <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以使用 <code>as</code> 运算符进行缩写：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(emp <span class="keyword">as</span> Person).firstName = <span class="string">&#x27;Bob&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>可以使用 <code>=</code> 来赋值，同时也可以使用 <code>??=</code> 来为值为 <code>null</code> 的变量赋值。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 value 赋值给 a (Assign value to a)</span></span><br><span class="line">a = value;</span><br><span class="line"><span class="comment">// 当且仅当 b 为 null 时才赋值</span></span><br><span class="line">b ??= value;</span><br></pre></td></tr></table></figure><p>像 <code>+=</code> 这样的赋值运算符将算数运算符和赋值运算符组合在了一起。<br>|         |      |       |       |       |       |<br>|  —-  | —-  | —-  | —-  | —-  | —-  |<br>|=    |–=    |/=|%=|    &gt;&gt;=|    ^=|<br>|+=    |*=| ~/=|&lt;&lt;=    |&amp;=|    =|<br>下面的例子展示了如何使用赋值以及复合赋值运算符：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a += b  <span class="comment">//就 等同于 a = a + b</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>; <span class="comment">// 使用 = 赋值 (Assign using =)</span></span><br><span class="line">a *= <span class="number">3</span>; <span class="comment">// 赋值并做乘法运算 Assign and multiply: a = a * 3</span></span><br><span class="line"><span class="keyword">assert</span>(a == <span class="number">6</span>);</span><br></pre></td></tr></table></figure><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><table><thead><tr><th>类型判断运算符</th><th>描述</th></tr></thead><tbody><tr><td>!表达式</td><td>对表达式结果取反（即将 true 变为 false，false 变为 true）</td></tr><tr><td>&#124;&#124;</td><td>逻辑或</td></tr><tr><td>&amp;&amp;</td><td>逻辑与</td></tr><tr><td>下面是使用逻辑表达式的示例：</td><td></td></tr></tbody></table><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!done &amp;&amp; (col == <span class="number">0</span> || col == <span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="comment">// ...Do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="按位和移位运算符"><a href="#按位和移位运算符" class="headerlink" title="按位和移位运算符"></a>按位和移位运算符</h4><table><thead><tr><th>按位和移位运算符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与</td></tr><tr><td>&#124;</td><td>按位或</td></tr><tr><td>^</td><td>按位异或</td></tr><tr><td>~ 表达式</td><td>按位取反（即将 “0” 变为 “1”，“1” 变为 “0”）</td></tr><tr><td>&lt;&lt;</td><td>位左移</td></tr><tr><td>&gt;&gt;</td><td>位右移</td></tr><tr><td>下面是使用按位和移位运算符的示例：</td><td></td></tr></tbody></table><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> value = <span class="number">0x22</span>;</span><br><span class="line"><span class="keyword">final</span> bitmask = <span class="number">0x0f</span>;</span><br><span class="line"><span class="keyword">assert</span>((value &amp; bitmask) == <span class="number">0x02</span>); <span class="comment">// 按位与 (AND)</span></span><br><span class="line"><span class="keyword">assert</span>((value &amp; ~bitmask) == <span class="number">0x20</span>); <span class="comment">// 取反后按位与 (AND NOT)</span></span><br><span class="line"><span class="keyword">assert</span>((value | bitmask) == <span class="number">0x2f</span>); <span class="comment">// 按位或 (OR)</span></span><br><span class="line"><span class="keyword">assert</span>((value ^ bitmask) == <span class="number">0x2d</span>); <span class="comment">// 按位异或 (XOR)</span></span><br><span class="line"><span class="keyword">assert</span>((value &lt;&lt; <span class="number">4</span>) == <span class="number">0x220</span>); <span class="comment">// 位左移 (Shift left)</span></span><br><span class="line"><span class="keyword">assert</span>((value &gt;&gt; <span class="number">4</span>) == <span class="number">0x02</span>); <span class="comment">// 位右移 (Shift right)</span></span><br></pre></td></tr></table></figure><h4 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h4><p><code>条件 ? 表达式 1 : 表达式 2</code> ：如果条件为 <code>true</code>，执行<code>表达式 1</code>并返回执行结果，否则执行<code>表达式 2</code> 并返回执行结果。<br><code>表达式 1 ?? 表达式 2</code>：如果<code>表达式 1</code> 为非 null 则返回其值，否则执行<code>表达式 2</code> 并返回其值。<br>如果赋值是根据布尔表达式则考虑使用 <code>?:</code>  </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> visibility = isPublic ? <span class="string">&#x27;public&#x27;</span> : <span class="string">&#x27;private&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果赋值是根据判定是否为 <code>null</code> 则考虑使用 <code>??</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> playerName(<span class="built_in">String</span> name) =&gt; name ?? <span class="string">&#x27;Guest&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上述示例还可以写成至少下面两种不同的形式，只是不够简洁：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相对使用 ?: 运算符来说稍微长了点。(Slightly longer version uses ?: operator).</span></span><br><span class="line"><span class="built_in">String</span> playerName(<span class="built_in">String</span> name) =&gt; name != <span class="keyword">null</span> ? name : <span class="string">&#x27;Guest&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果使用 if-else 则更长。</span></span><br><span class="line"><span class="built_in">String</span> playerName(<span class="built_in">String</span> name) &#123;</span><br><span class="line">  <span class="keyword">if</span> (name != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Guest&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="级联运算符"><a href="#级联运算符" class="headerlink" title="级联运算符"></a>级联运算符</h4><p>级联运算符<code>（..）</code>可以让你在同一个对象上连续调用多个对象的变量或方法。<br>比如下面的代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">querySelector</span>(<span class="string">&#x27;#confirm&#x27;</span>) <span class="comment">// 获取对象 (Get an object).</span></span><br><span class="line">  ..text = <span class="string">&#x27;Confirm&#x27;</span> <span class="comment">// 使用对象的成员 (Use its members).</span></span><br><span class="line">  ..classes.add(<span class="string">&#x27;important&#x27;</span>)</span><br><span class="line">  ..onClick.listen((e) =&gt; <span class="built_in">window</span>.alert(<span class="string">&#x27;Confirmed!&#x27;</span>));</span><br></pre></td></tr></table></figure><p>第一个方法 <code>querySelector</code> 返回了一个 <code>Selector</code> 对象，后面的级联操作符都是调用这个 <code>Selector</code> 对象的成员并忽略每个操作的返回值。</p><p>上面的代码相当于：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">querySelector</span>(<span class="string">&#x27;#confirm&#x27;</span>);</span><br><span class="line">button.text = <span class="string">&#x27;Confirm&#x27;</span>;</span><br><span class="line">button.classes.add(<span class="string">&#x27;important&#x27;</span>);</span><br><span class="line">button.onClick.listen((e) =&gt; <span class="built_in">window</span>.alert(<span class="string">&#x27;Confirmed!&#x27;</span>));</span><br></pre></td></tr></table></figure><p>级联运算符可以嵌套，例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> addressBook = (AddressBookBuilder()</span><br><span class="line">      ..name = <span class="string">&#x27;jenny&#x27;</span></span><br><span class="line">      ..email = <span class="string">&#x27;jenny@example.com&#x27;</span></span><br><span class="line">      ..phone = (PhoneNumberBuilder()</span><br><span class="line">            ..number = <span class="string">&#x27;415-555-0100&#x27;</span></span><br><span class="line">            ..label = <span class="string">&#x27;home&#x27;</span>)</span><br><span class="line">          .build())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>在返回对象的函数中谨慎使用级联操作符。例如，下面的代码是错误的：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sb = <span class="built_in">StringBuffer</span>();</span><br><span class="line">sb.write(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">  ..write(<span class="string">&#x27;bar&#x27;</span>); <span class="comment">// 出错：void 对象中没有方法 write (Error: method &#x27;write&#x27; isn&#x27;t defined for &#x27;void&#x27;).</span></span><br></pre></td></tr></table></figure><p>上述代码中的 <code>sb.write()</code> 方法返回的是 <code>void</code>，返回值为 <code>void</code> 的方法则不能使用级联运算符。</p><h4 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h4><p>大多数其它的运算符，已经在其它的示例中使用过：<br>| 运算符   | 名字  |  描述 |<br>| —   | —  |  — |<br>|()    |使用方法    |代表调用一个方法|<br>|[]    |访问 List    |访问 List 中特定位置的元素|<br>|.    |访问成员|    成员访问符|<br>|?.    |条件访问成员|    与上述成员访问符类似，但是左边的操作对象不能为 null，例如 foo?.bar，如果 foo 为 null 则返回 null ，否则返回 bar|</p><p>更多关于 <code>., ?.</code> 和 <code>..</code> 运算符介绍，会在下一章<strong>Flutter手把手教程Dart语言——类</strong>中讲解.</p><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart语言 </tag>
            
            <tag> Dart运算符 </tag>
            
            <tag> Flutter教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>artipub点击&quot;更新cookie状态&quot;无任何反应</title>
      <link href="tips-artipub-cookies-6.html"/>
      <url>tips-artipub-cookies-6.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h3 id="artipub"><a href="#artipub" class="headerlink" title="artipub"></a>artipub</h3><p><a href="https://github.com/crawlab-team/artipub">ArtiPub</a> (Article Publisher 的简称，意为 “文章发布者”) 是一款开源的一文多发平台，可以帮助文章作者将编写好的文章自动发布到掘金、SegmentFault、CSDN、知乎、开源中国等技术媒体平台。</p><a id="more"></a><p>点击”更新cookie状态”按钮之后错误如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 400</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 954)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 400</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 956)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 503</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 958)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 400</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 960)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 400</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 962)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 400</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 964)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 400</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 966)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 400</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 968)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 400</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 970)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 503</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 972)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 400</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 974)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 400</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 976)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 400</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 978)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 503</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 980)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 400</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 982)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 400</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 984)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 400</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 986)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 503</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 988)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 503</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 990)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 503</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 992)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 503</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 994)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 503</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 996)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 503</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 998)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 503</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 1000)</span><br></pre></td></tr></table></figure><h4 id="运行环境："><a href="#运行环境：" class="headerlink" title="运行环境："></a>运行环境：</h4><ul><li>macOS 10.15.5</li><li>已安装mogodb并已启动</li><li>已启动<code>npm run start:frontend</code></li><li>登录助手已安装正确<h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4>这是因为执行<code>npm run start:backend</code>命令时没有添加<code>sudo</code>权限的问题。<br>使用<code>sudo npm run start:backend</code>启动，然后再点击”更新cookies”状态就可以了。</li></ul><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python 1-8】Python手把手教程之——管理列表List</title>
      <link href="python-handle-list-1-8.html"/>
      <url>python-handle-list-1-8.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><p>在<a href="http://fulade.me/python-list-7.html">上一节</a>我们学习了如何创建一个列表，在列表里面插入、删除数据等操作。<br>本节我们学习如何管理列表。</p><h3 id="遍历列表"><a href="#遍历列表" class="headerlink" title="遍历列表"></a>遍历列表</h3><p>在日常开发中，我们经常需要遍历列表的所有元素，对每个元素执行相同的操作。例如，在管理商场的蔬菜时候，需要给所有的蔬菜商品都打7折，并重新生成价格。当我们需要对列表中的每个元素都执行相同的操作时，可使用Python中的<code>for</code>循环。</p><a id="more"></a><p>假设我们有一个蔬菜名单，需要将其中每种蔬菜的名字都打印出来。为此，我们可以采用元素下标的方式分别获取名单中的每个名字，但这种做法会导致多个问题。例如，如果名单很长，将包含大量重复的代码。另外，每当名单的长度发生变化时，都必须修改代码。通过使用<code>for</code>循环，可让<code>Python</code>去处理这些问题。<br>下面使用for循环来打印蔬菜单中的所有名字:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vegetables = [<span class="string">&#x27;potato&#x27;</span>,<span class="string">&#x27;tomato&#x27;</span>,<span class="string">&#x27;onion&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> vegetables:</span><br><span class="line">    print(name)</span><br></pre></td></tr></table></figure><p>这行代码让Python从列表<code>vegetables</code>中取出一个名字，并将其存储在变量<code>name</code>中。最后，我们让Python打印前面存储的变量<code>name</code>中的名字。这样，对于列表中的每个名字，Python都将重复执行<code>print(name)</code>代码。你可以这样解读这些代码：对于列表<code>vegetables</code>中的每种蔬菜，都将其名字打印出来。输出很简单，就是列表中所有蔬菜的姓名:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">potato</span><br><span class="line">tomato</span><br><span class="line">onion</span><br></pre></td></tr></table></figure><h5 id="详解遍历列表执行过程"><a href="#详解遍历列表执行过程" class="headerlink" title="详解遍历列表执行过程"></a>详解遍历列表执行过程</h5><p>循环这种概念很重要，因为它是让计算机自动完成重复工作的常见方式之一。例如，在前面的代码中使用的简单循环中，Python将首先读取其中的第一行代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> vegetables:</span><br></pre></td></tr></table></figure><p>这行代码让Python获取列表<code>vegetables</code>中的第一个值<code>potato</code>，并将其存储到变量<code>name</code> 中。接下来，Python读取下一行代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(name) </span><br></pre></td></tr></table></figure><p>它让Python打印<code>vegetables</code>的值<code>potato</code>。由于该列表还包含其他值，Python返回到循环的第一行:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> vegetables:</span><br></pre></td></tr></table></figure><p>Python获取列表中的下一个名字<code>tomato</code>，并将其存储到变量<code>name</code>中，再执行下面这行代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(name) </span><br></pre></td></tr></table></figure><p>Python再次打印变量<code>vegetables</code>的值<code>tomato</code>。<br>接下来，Python再次执行整个循环，对列表中的最后一个值<code>onion</code>进行处理。<br>至此，列表中没有其他的值了，因此Python接着执行程序的下一行代码。在这个示例中，<code>for</code>循环后面没有其他的代码，因此程序就此结束。<br>刚开始使用循环时需要牢记，对列表中的每个元素，都将执行循环指定的步骤，而不管列表包含多少个元素。如果列表包含一百万个元素，Python就重复执行指定的步骤一百万次，且通常速度非常快。<br>另外，编写<code>for</code>循环时，对于用于存储列表中每个值的临时变量，可指定任何名称。比如说：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> dog <span class="keyword">in</span> dogs:</span><br><span class="line"><span class="keyword">for</span> cat <span class="keyword">in</span> cats:</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> item_list:</span><br></pre></td></tr></table></figure><p>这些写法都是可以的。</p><h5 id="在For循环中做更多操作"><a href="#在For循环中做更多操作" class="headerlink" title="在For循环中做更多操作"></a>在For循环中做更多操作</h5><p>在for循环中，可以获取到每一个元素，可对每个元素执行任何操作。比如说我们对每一种蔬菜都输出一句话。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vegetables = [<span class="string">&#x27;potato&#x27;</span>,<span class="string">&#x27;tomato&#x27;</span>,<span class="string">&#x27;onion&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> vegetables:</span><br><span class="line">    print(name + <span class="string">&#x27; is good !&#x27;</span>)</span><br></pre></td></tr></table></figure><p>相比于前一个示例，唯一的不同是对于每种蔬菜，都打印了一条以其名字为抬头的消息。这个循环第一次迭代时，变量<code>name</code>的值为<code>potato</code>，因此Python打印的第一条消息的抬头为<code>potato</code>。第二次迭代时，消息的抬头为<code>tomato</code>，而第三次迭代时，抬头为<code>onion</code>。<br>下面的输出表明，对于列表中的每种蔬菜，都打印了一条个性化消息:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">potato <span class="keyword">is</span> good !</span><br><span class="line">tomato <span class="keyword">is</span> good !</span><br><span class="line">onion <span class="keyword">is</span> good !</span><br></pre></td></tr></table></figure><p>在for循环中，想包含多少行代码都可以。在代码行<code>for name in vegetables</code>后面，每个<strong>缩进的</strong>代码行都是循环的一部分，且将针对列表中的每个值都执行一次。因此，可对列表中的每个值执行任意次数的操作。<br>下面再添加一行代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vegetables = [<span class="string">&#x27;potato&#x27;</span>,<span class="string">&#x27;tomato&#x27;</span>,<span class="string">&#x27;onion&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> vegetables:</span><br><span class="line">    print(name + <span class="string">&#x27; is good !&#x27;</span>)</span><br><span class="line">    print(name + <span class="string">&#x27; is a vegetable!&#x27;</span>)</span><br></pre></td></tr></table></figure><p>由于两条<code>print</code>语句都缩进了，因此它们都将针对列表中的每位蔬菜都执行一次。输出结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">potato <span class="keyword">is</span> good !</span><br><span class="line">potato <span class="keyword">is</span> a vegetable!</span><br><span class="line">tomato <span class="keyword">is</span> good !</span><br><span class="line">tomato <span class="keyword">is</span> a vegetable!</span><br><span class="line">onion <span class="keyword">is</span> good !</span><br><span class="line">onion <span class="keyword">is</span> a vegetable!</span><br></pre></td></tr></table></figure><p>在<code>for</code>循环中，想包含多少行代码都可以。这种方式在开发过程中很有用。</p><h3 id="避免缩进错误"><a href="#避免缩进错误" class="headerlink" title="避免缩进错误"></a>避免缩进错误</h3><p>Python根据<strong>缩进</strong>来判断代码行与前一个代码行的关系。在前面的示例中，对每种蔬菜的输出代码行是<code>for</code>循环的一部分，因为它们缩进了。Python通过使用缩进让代码更易读。<br>简单地说，它要求你使用缩进让代码整洁而结构清晰。在较长的Python程序中，你将看到缩进程度各不相同的代码块，这让你对程序的组织结构有大致的认识。 当你开始使用缩进时，需要注意一些常见的缩进错误。<br>例如，有时候，程序员会将不需要缩进的代码块缩进，而对于必须缩进的代码块却忘了缩进。通过查看这些错误示例，有助于我们以后避开它们，以及在它们出现在程序中时进行修复。下面来看一些较为常见的缩进错误。</p><h5 id="忘记缩进"><a href="#忘记缩进" class="headerlink" title="忘记缩进"></a>忘记缩进</h5><p>对于位于<code>for</code>语句后面且属于循环组成部分的代码行，一定要缩进。如果你忘记缩进，运行会直接报错:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vegetables = [<span class="string">&#x27;potato&#x27;</span>,<span class="string">&#x27;tomato&#x27;</span>,<span class="string">&#x27;onion&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> vegetables:</span><br><span class="line">print(name)</span><br></pre></td></tr></table></figure><p><code>print</code>语句应缩进却没有缩进。Python没有找到期望缩进的代码块时，会让你知道哪行代码有问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">2</span></span><br><span class="line">    print(name)</span><br><span class="line">        ^</span><br><span class="line">IndentationError: expected an indented block</span><br></pre></td></tr></table></figure><p>通常，将紧跟在for语句后面的代码行缩进，可消除这种缩进错误。</p><h5 id="忘记缩进额外的代码行"><a href="#忘记缩进额外的代码行" class="headerlink" title="忘记缩进额外的代码行"></a>忘记缩进额外的代码行</h5><p>有时候，循环能够运行而不会报告错误，但结果可能会出乎意料。试图在循环中执行多项任务，却忘记缩进其中的一些代码行时，就会出现这种情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vegetables = [<span class="string">&#x27;potato&#x27;</span>,<span class="string">&#x27;tomato&#x27;</span>,<span class="string">&#x27;onion&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> vegetables:</span><br><span class="line">    print(name + <span class="string">&#x27; is good !&#x27;</span>)</span><br><span class="line">print(name + <span class="string">&#x27; is a vegetable!&#x27;</span>)</span><br></pre></td></tr></table></figure><p>第二个<code>print</code>语句原本需要缩进，但Python发现<code>for</code>语句后面有一行代码是缩进的，因此它没有报告错误。最终的结果是，对于列表中的每种蔬菜，都执行了第一条<code>print</code>语句，因为它缩进了；而第二条<code>print</code>语句没有缩进，因此它只在循环结束后执行一次。由于变量 <code>name</code> 的终值为<code>onion</code>，因此只有一条输出了<code>onion is a vegetable!</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">potato <span class="keyword">is</span> good !</span><br><span class="line">tomato <span class="keyword">is</span> good !</span><br><span class="line">onion <span class="keyword">is</span> good !</span><br><span class="line">onion <span class="keyword">is</span> a vegetable!</span><br></pre></td></tr></table></figure><p>这是一个逻辑错误。从语法上看，这些代码是没问题的，但由于存在逻辑错误，结果并不符合预期。如果你预期某项操作将针对每个列表元素都执行一次，但它却只执行了一次，请确定是否需要将一行或多行代码缩进。</p><h5 id="不必要的缩进"><a href="#不必要的缩进" class="headerlink" title="不必要的缩进"></a>不必要的缩进</h5><p>如果你不小心缩进了无需缩进的代码行，同样运行的时候也会报错:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="string">&quot;Hello Python world!&quot;</span></span><br><span class="line">    print(message)</span><br></pre></td></tr></table></figure><p><code>print</code>语句无需缩进，因为它并不属于前一行代码，运行的时候会帮我们指出这种错误:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    print(message)</span><br><span class="line">    ^</span><br><span class="line">IndentationError: unexpected indent</span><br></pre></td></tr></table></figure><p>为避免意外缩进错误，请只缩进需要缩进的代码。在前面编写的程序中，只有要在<code>for</code>循环中对每个元素执行的代码就需要缩进。</p><h5 id="循环后不必要的缩进"><a href="#循环后不必要的缩进" class="headerlink" title="循环后不必要的缩进"></a>循环后不必要的缩进</h5><p>如果我们不小心缩进了应在循环结束后执行的代码，这些代码将针对每个列表元素重复执行。 在有些情况下，这可能导致Python报告语法错误，但在大多数情况下，这只会导致逻辑错误。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vegetables = [<span class="string">&#x27;potato&#x27;</span>,<span class="string">&#x27;tomato&#x27;</span>,<span class="string">&#x27;onion&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> vegetables:</span><br><span class="line">    print(name + <span class="string">&#x27; is good !&#x27;</span>)</span><br><span class="line">    print(name + <span class="string">&#x27; is a vegetable!&#x27;</span>)</span><br><span class="line">    <span class="comment">## 这一行代码被缩进</span></span><br><span class="line">    print(<span class="string">&#x27;There are three kinds of vegetables.&#x27;</span>)</span><br></pre></td></tr></table></figure><p>那么输出就会变成以下这个样子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">potato <span class="keyword">is</span> good !</span><br><span class="line">potato <span class="keyword">is</span> a vegetable!</span><br><span class="line">There are three kinds of vegetables</span><br><span class="line">tomato <span class="keyword">is</span> good !</span><br><span class="line">tomato <span class="keyword">is</span> a vegetable!</span><br><span class="line">There are three kinds of vegetables</span><br><span class="line">onion <span class="keyword">is</span> good !</span><br><span class="line">onion <span class="keyword">is</span> a vegetable!</span><br><span class="line">There are three kinds of vegetables.</span><br></pre></td></tr></table></figure><p>这也是一个逻辑错误。Python不知道你的本意，只要代码符合语法，它就会运行。所以我们应该时刻保持警惕，不要用错了缩进。</p><h5 id="遗漏了冒号"><a href="#遗漏了冒号" class="headerlink" title="遗漏了冒号"></a>遗漏了冒号</h5><p><code>for</code>语句末尾的冒号告诉Python，下一行是循环的第一行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vegetables = [<span class="string">&#x27;potato&#x27;</span>,<span class="string">&#x27;tomato&#x27;</span>,<span class="string">&#x27;onion&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> vegetables</span><br><span class="line">    print(name + <span class="string">&#x27; is good !&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> vegetables</span><br><span class="line">                         ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><p>如果你不小心遗漏了冒号，如上所示，将导致语法错误，因为Python不知道你意欲何为。这种错误虽然易于消除，但并不那么容易发现。</p><h3 id="数值列表"><a href="#数值列表" class="headerlink" title="数值列表"></a>数值列表</h3><p>Python函数<code>range()</code>让你能够轻松地生成一系列的数字。例如，可以像下面这样使用函数<code>range()</code>来打印一系列的数字:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">    print(value)</span><br></pre></td></tr></table></figure><p>上述代码好像应该打印数字1~5，但实际上它不会打印数字5:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>在这个示例中，<code>range()</code>只是打印数字1<del>4，这是你在编程语言中经常看到的差一行为的结果。函数<code>range()</code>让Python从你指定的第一个值开始数，并在到达你指定的第二个值后停止，因此输出不包含第二个值(这里为5)。<br>要打印数字1</del>5，需要使用<code>range(1,6)</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>):</span><br><span class="line">    print(value)</span><br></pre></td></tr></table></figure><p>这样，输出将从1开始，到5结束:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>使用<code>range()</code>时，如果输出不符合预期，请尝试将指定的值加<code>1</code>或减<code>1</code>。</p><h5 id="使用range-创建数字列表"><a href="#使用range-创建数字列表" class="headerlink" title="使用range()创建数字列表"></a>使用range()创建数字列表</h5><p>要创建数字列表，可使用函数<code>list()</code>将<code>range()</code>的结果直接转换为列表。如果将<code>range()</code>作为<code>list()</code>的参数，输出将为一个数字列表。<br>在上面的示例中，我们打印了一系列数字。要将这些数字转换为一个列表，可使用<code>list():</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>))</span><br><span class="line">print(numbers)</span><br></pre></td></tr></table></figure><p>结果如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>使用函数<code>range()</code>时，还可指定<strong>步长</strong>。例如，下面的代码打印1~10内的偶数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">even_numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">2</span>,<span class="number">11</span>,<span class="number">2</span>)) </span><br><span class="line">print(even_numbers)</span><br></pre></td></tr></table></figure><p>在这个示例中，函数<code>range()</code>从2开始数，然后不断地加2，直到达到或超过终值(11)，因此 输出如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>使用函数<code>range()</code>几乎能够创建任何需要的数字集，例如，如何创建一个列表，其中包含前10个整数(即1~10)的平方呢？在Python中，两个星号<code>**</code>表示乘方运算。下面的代码演示如何将前10个整数的平方加入到一个列表中:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">squares = []</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">    square = value**<span class="number">2</span></span><br><span class="line">    squares.append(square)</span><br><span class="line">print(squares)</span><br></pre></td></tr></table></figure><p>首先，我们创建了一个空列表；接下来，使用函数<code>range()</code>让Python遍历1~10的值。在循环中，计算当前值的平方，并将结果存储到变量square中。然后，将新计算得到的平方值附加到列表<code>squares</code>末尾。最后，循环结束后，打印列表<code>squares</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure><h5 id="对数字列表执行简单的统计计算"><a href="#对数字列表执行简单的统计计算" class="headerlink" title="对数字列表执行简单的统计计算"></a>对数字列表执行简单的统计计算</h5><p>有几个专门用于处理数字列表的Python函数。例如，你可以轻松地找出数字列表的最大值、最小值和总和:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">digits = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>] </span><br><span class="line"><span class="comment">### 输出最小值</span></span><br><span class="line">print(<span class="built_in">min</span>(digits))</span><br><span class="line"><span class="comment">### 输出最大值</span></span><br><span class="line">print(<span class="built_in">max</span>(digits))</span><br><span class="line"><span class="comment">### 计算总和</span></span><br><span class="line">print(<span class="built_in">sum</span>(digits))</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">45</span></span><br></pre></td></tr></table></figure><h5 id="列表解析"><a href="#列表解析" class="headerlink" title="列表解析"></a>列表解析</h5><p>列表解析将<code>for</code>循环和创建新元素的代码合并成一行，并自动附加新元素。下面的示例使用列表解析创建你在前面看到的平方数列表:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">squares = [value**<span class="number">2</span> <span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>)] </span><br><span class="line">print(squares)</span><br></pre></td></tr></table></figure><p>要使用这种语法，首先指定一个描述性的列表名，如<code>squares</code>；然后，指定一个左方括号，并定义一个表达式，用于生成你要存储到列表中的值。在这个示例中，表达式为<code>value**2</code>，它来计算平方值。接下来，编写一个for循环，用于给表达式提供值，再加上右方括号。在这个示例中，<code>for</code>循环为<code>for value in range(1,11)</code>，它将值1~10提供给表达式<code>value**2</code>。请注意，这里的for语句末尾没有冒号。<br>  结果与你在前面看到的平方数列表相同:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure><p>要创建自己的列表解析，需要经过一定的练习，但能够熟练地创建常规列表后，你会发现这样做是完全值得的。当你觉得编写三四行代码来生成列表有点繁复时，就应考虑创建列表解析了。</p><h3 id="列表中的一部分"><a href="#列表中的一部分" class="headerlink" title="列表中的一部分"></a>列表中的一部分</h3><p>在上面的内容中，我们学习了如何访问单个列表元素。接下来，我们将学习如何处理列表的所有元素。我们还可以处理列表的部分元素——Python称之为<strong>切片</strong>。</p><h5 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h5><p>要创建切片，可指定要使用的第一个元素和最后一个元素的索引。与函数<code>range()</code>一样，Python 在到达你指定的第二个索引前面的元素后停止。要输出列表中的前三个元素，需要指定索引0~3， 这将输出分别为0、1和2的元素。<br>我们还是以蔬菜列表为例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vegetables = [<span class="string">&#x27;potato&#x27;</span>,<span class="string">&#x27;tomato&#x27;</span>,<span class="string">&#x27;onion&#x27;</span>,<span class="string">&#x27;leek&#x27;</span>]</span><br><span class="line">print(vegetables[<span class="number">0</span>:<span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>上面的代码打印该列表的一个切片，其中只包含三种蔬菜。输出也是一个列表，其中包含前三种蔬菜:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;potato&#x27;</span>, <span class="string">&#x27;tomato&#x27;</span>, <span class="string">&#x27;onion&#x27;</span>]</span><br></pre></td></tr></table></figure><p>你可以生成列表的任何子集，例如，如果你要提取列表的第2~4个元素，可将起始索引指定为1，并将终止索引指定为4:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vegetables = [<span class="string">&#x27;potato&#x27;</span>,<span class="string">&#x27;tomato&#x27;</span>,<span class="string">&#x27;onion&#x27;</span>,<span class="string">&#x27;leek&#x27;</span>]</span><br><span class="line">print(vegetables[<span class="number">1</span>:<span class="number">4</span>])</span><br></pre></td></tr></table></figure><p>这一次，切片始于<code>tomato</code>，终于<code>leek</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;tomato&#x27;</span>, <span class="string">&#x27;onion&#x27;</span>, <span class="string">&#x27;leek&#x27;</span>]</span><br></pre></td></tr></table></figure><p>如果你没有指定第一个索引，Python将自动从列表开头开始:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vegetables = [<span class="string">&#x27;potato&#x27;</span>,<span class="string">&#x27;tomato&#x27;</span>,<span class="string">&#x27;onion&#x27;</span>,<span class="string">&#x27;leek&#x27;</span>]</span><br><span class="line">print(vegetables[:<span class="number">4</span>])</span><br></pre></td></tr></table></figure><p>由于没有指定起始索引，Python从列表开头开始提取:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;potato&#x27;</span>, <span class="string">&#x27;tomato&#x27;</span>, <span class="string">&#x27;onion&#x27;</span>, <span class="string">&#x27;leek&#x27;</span>]</span><br></pre></td></tr></table></figure><p>要让切片终止于列表末尾，也可使用类似的语法。例如，如果要提取从第3个元素到列表末 尾的所有元素，可将起始索引指定为2，并省略终止索引:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vegetables = [<span class="string">&#x27;potato&#x27;</span>,<span class="string">&#x27;tomato&#x27;</span>,<span class="string">&#x27;onion&#x27;</span>,<span class="string">&#x27;leek&#x27;</span>]</span><br><span class="line">print(vegetables[<span class="number">2</span>:])</span><br></pre></td></tr></table></figure><p>Python将返回从第3个元素到列表末尾的所有元素:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;onion&#x27;</span>, <span class="string">&#x27;leek&#x27;</span>]</span><br></pre></td></tr></table></figure><p>无论列表多长，这种语法都能够让你输出从特定位置到列表末尾的所有元素。前面我们了解过，负数索引返回离列表末尾相应距离的元素，因此你可以输出列表末尾的任何切片。例如，如果你要输出名单上的最后三种蔬菜，可使用切片<code>vegetables[-3:]</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vegetables = [<span class="string">&#x27;potato&#x27;</span>,<span class="string">&#x27;tomato&#x27;</span>,<span class="string">&#x27;onion&#x27;</span>,<span class="string">&#x27;leek&#x27;</span>]</span><br><span class="line">print(vegetables[-<span class="number">3</span>:])</span><br><span class="line">[<span class="string">&#x27;tomato&#x27;</span>, <span class="string">&#x27;onion&#x27;</span>, <span class="string">&#x27;leek&#x27;</span>]</span><br></pre></td></tr></table></figure><h5 id="遍历切片"><a href="#遍历切片" class="headerlink" title="遍历切片"></a>遍历切片</h5><p>如果要遍历列表的部分元素，可在for循环中使用切片。在下面的示例中，我们遍历前三种蔬菜，并打印它们的名字:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vegetables = [<span class="string">&#x27;potato&#x27;</span>,<span class="string">&#x27;tomato&#x27;</span>,<span class="string">&#x27;onion&#x27;</span>,<span class="string">&#x27;leek&#x27;</span>]</span><br><span class="line">print(<span class="string">&quot;Here are the first three vegetable:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> vegetables[:<span class="number">3</span>]:</span><br><span class="line">    print(name.title())</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Here are the first three vegetable:</span><br><span class="line">Potato</span><br><span class="line">Tomato</span><br><span class="line">Onion</span><br></pre></td></tr></table></figure><p>在很多情况下，切片都很有用。例如，编写游戏时，你可以在玩家退出游戏时将其最终得分加入到一个列表中。然后，为获取该玩家的三个最高得分，你可以将该列表按降序排列，再创建一个只包含前三个得分的切片。处理数据时，可使用切片来进行批量处理；编写Web应用程序时，可使用切片来分页显示信息，并在每页显示数量合适的信息。</p><h5 id="复制列表"><a href="#复制列表" class="headerlink" title="复制列表"></a>复制列表</h5><p>我们经常需要根据既有列表创建全新的列表。下面来介绍复制列表的工作原理，以及复制列表可提供极大帮助。<br>要复制列表，可创建一个包含整个列表的切片，方法是同时省略起始索引和终止索引(<code>[:]</code>)。 这让Python创建一个始于第一个元素，终止于最后一个元素的切片，即复制整个列表。<br>例如，假设有一个列表，其中包含你最喜欢的四种食品，而你还想创建另一个列表，在其中包含一位朋友喜欢的所有食品。不过，你喜欢的食品，这位朋友都喜欢，因此你可以通过复制来创建这个列表:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_foods = [<span class="string">&#x27;pizza&#x27;</span>, <span class="string">&#x27;falafel&#x27;</span>, <span class="string">&#x27;carrot cake&#x27;</span>] friend_foods = my_foods[:]</span><br><span class="line">print(<span class="string">&quot;My favorite foods are:&quot;</span>) </span><br><span class="line">print(my_foods)</span><br><span class="line">print(<span class="string">&quot;\nMy friend&#x27;s favorite foods are:&quot;</span>) </span><br><span class="line">print(friend_foods)</span><br></pre></td></tr></table></figure><p>我们首先创建了一个名为<code>my_foods</code>的食品列表，然后创建了一个名为<code>friend_foods</code>的新列表。我们在不指定任何索引的情况下从列表<code>my_foods</code>中提取一个切片，从而创建了这个列表的副本，再将该副本存储到变量<code>friend_foods</code>中。打印每个列表后，我们发现它们包含的食品相同:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">My favorite foods are:</span><br><span class="line">[<span class="string">&#x27;pizza&#x27;</span>, <span class="string">&#x27;falafel&#x27;</span>, <span class="string">&#x27;carrot cake&#x27;</span>]</span><br><span class="line">My friend<span class="string">&#x27;s favorite foods are: </span></span><br><span class="line"><span class="string">[&#x27;</span>pizza<span class="string">&#x27;, &#x27;</span>falafel<span class="string">&#x27;, &#x27;</span>carrot cake<span class="string">&#x27;]</span></span><br></pre></td></tr></table></figure><p>为了核实我们确实有两个列表，下面在每个列表中都添加一种食品，并核实每个列表都记录了相应人员喜欢的食品:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_foods = [<span class="string">&#x27;pizza&#x27;</span>, <span class="string">&#x27;falafel&#x27;</span>, <span class="string">&#x27;carrot cake&#x27;</span>] <span class="number">5</span></span><br><span class="line">friend_foods = my_foods[:]</span><br><span class="line">my_foods.append(<span class="string">&#x27;cannoli&#x27;</span>)</span><br><span class="line">friend_foods.append(<span class="string">&#x27;ice cream&#x27;</span>) </span><br><span class="line">print(<span class="string">&quot;My favorite foods are:&quot;</span>)</span><br><span class="line">print(my_foods)</span><br><span class="line">print(<span class="string">&quot;\nMy friend&#x27;s favorite foods are:&quot;</span>) </span><br><span class="line">print(friend_foods)</span><br></pre></td></tr></table></figure><p>与前一个示例一样，我们首先将<code>my_foods</code>的元素复制到新列表<code>friend_foods</code>中。接下来，在每个列表中都添加一种食品:在列表<code>my_foods</code>中添加<code>cannoli</code>，而在<code>friend_foods</code>中添加<code>ice cream</code>。最后，打印这两个列表，核实这两种食品包含在正确的列表中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">My favorite foods are:</span><br><span class="line">[<span class="string">&#x27;pizza&#x27;</span>, <span class="string">&#x27;falafel&#x27;</span>, <span class="string">&#x27;carrot cake&#x27;</span>, <span class="string">&#x27;cannoli&#x27;</span>]</span><br><span class="line">My friend<span class="string">&#x27;s favorite foods are:</span></span><br><span class="line"><span class="string">[&#x27;</span>pizza<span class="string">&#x27;, &#x27;</span>falafel<span class="string">&#x27;, &#x27;</span>carrot cake<span class="string">&#x27;, &#x27;</span>ice cream<span class="string">&#x27;]</span></span><br><span class="line"><span class="string">``` </span></span><br><span class="line"><span class="string">上面的输出表明，`cannoli`包含在你喜欢的食品列表中，而`ice cream`没有。`ice cream`包含在你朋友喜欢的食品列表中，而`cannoli`没有。倘若我们只是简单地将`my_foods`赋给`friend_foods`，就不能得到两个列表。例如，下例演示了在不使用切片的情况下复制列表的情况:</span></span><br><span class="line"><span class="string">``` python</span></span><br><span class="line"><span class="string">my_foods = [&#x27;</span>pizza<span class="string">&#x27;, &#x27;</span>falafel<span class="string">&#x27;, &#x27;</span>carrot cake<span class="string">&#x27;]</span></span><br><span class="line"><span class="string">#这行不通 </span></span><br><span class="line"><span class="string">friend_foods = my_foods</span></span><br><span class="line"><span class="string">my_foods.append(&#x27;</span>cannoli<span class="string">&#x27;) </span></span><br><span class="line"><span class="string">friend_foods.append(&#x27;</span>ice cream<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">print(&quot;My favorite foods are:&quot;) </span></span><br><span class="line"><span class="string">print(my_foods)</span></span><br><span class="line"><span class="string">print(&quot;\nMy friend&#x27;</span>s favorite foods are:<span class="string">&quot;) </span></span><br><span class="line"><span class="string">print(friend_foods)</span></span><br></pre></td></tr></table></figure><p>这里将<code>my_foods</code>赋给<code>friend_foods</code>，而不是将<code>my_foods</code>的副本存储到<code>friend_foods</code>。这种语法实际上是让Python将新变量<code>friend_foods</code>关联到包含在<code>my_foods</code>中的列表，因此这两个变量都指向同一个列表。鉴于此，当我们将<code>cannoli</code>添加到<code>my_foods</code>中时，它也将出现在<code>friend_food</code>中；同样，虽然<code>ice cream</code>好像只被加入到了<code>friend_foods</code>中，但它也将出现在这两个列表中。<br>输出表明，两个列表是相同的，这并非我们想要的结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">My favorite foods are:</span><br><span class="line">[<span class="string">&#x27;pizza&#x27;</span>, <span class="string">&#x27;falafel&#x27;</span>, <span class="string">&#x27;carrot cake&#x27;</span>, <span class="string">&#x27;cannoli&#x27;</span>, <span class="string">&#x27;ice cream&#x27;</span>]</span><br><span class="line">My friend<span class="string">&#x27;s favorite foods are:</span></span><br><span class="line"><span class="string">[&#x27;</span>pizza<span class="string">&#x27;, &#x27;</span>falafel<span class="string">&#x27;, &#x27;</span>carrot cake<span class="string">&#x27;, &#x27;</span>cannoli<span class="string">&#x27;, &#x27;</span>ice cream<span class="string">&#x27;]</span></span><br></pre></td></tr></table></figure><blockquote><p>8-1 动物:想出至少三种有共同特征的动物，将这些动物的名称存储在一个列表中，再使用for循环将每种动物的名称都打印出来。<br> 修改这个程序，使其针对每种动物都打印一个句子，如”A dog would make a great pet”。在程序末尾添加一行代码，指出这些动物的共同之处，如打印诸如”Any of these animals would make a great pet!”这样的句子。<br>8-2  数到 20:使用一个 for 循环打印数字 1<del>20(含)。<br>8-3 计算 1</del> 1000000 的总和:创建一个列表，其中包含数字1<del>1000000，再使用min()和max()核实该列表确实是从1开始，到1000000 结束的。另外，对这个列表调用函数sum()，体会一下Python将一百万个数字相加需要多长时间。<br>8-4 3的倍数:创建一个列表，其中包含 3</del>30 内能被3整除的数字;再使用一个for循环将这个列表中的数字都打印出来。<br>8-5 切片:修改8-1的代码，在末尾添加几行代码，以完成如下任务。 打印消息”The first three items in the list are:”，再使用切片来打印列表的前三个元素。打印消息”Three items from the middle of the list are:”，再使用切片来打印列表中间的三个元素。打印消息”The last three items in the list are:”，再使用切片来打印列表末尾的三个元素。</p></blockquote><p>想查看作业答案可以去<a href="https://github.com/Johnson8888/learn_python">我的Githu仓库</a></p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免费送书啦！细数Github大神们的开源书籍！</title>
      <link href="tips-github-free-books-3.html"/>
      <url>tips-github-free-books-3.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h3 id="Go-系列"><a href="#Go-系列" class="headerlink" title="Go 系列"></a>Go 系列</h3><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_2.jpeg" /></p><p align="center">《Mastering GO》</p><blockquote><p>推荐语：本书适用于Golang程序员。您之前应该阅读有关Go的介绍性书籍。本书的内容包括但不限于并发、网络编程、垃圾回收、组合、GO UNIX系统编程、基本数据类型（Array,Slice,Map）、GO源码、反射，接口，类型方法等高级概念。阅读本书需要一定的编程经验。如果你在工作中使用Go或者业余时间爱好GO，那么这本书一定会让你对GO的理解更上一层楼。<br><a href="https://github.com/hantmac/Mastering_Go_ZH_CN">领取地址</a></p></blockquote><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_6.png" /></p><p align="center">《Go语法树入门——开启自制编程语言和编译器之旅》</p>  <blockquote><p>Go语法树是Go语言源文件的另一种语义等价的表现形式。而Go语言自带的go fmt和go doc等命令都是在Go语法树的基础之上分析工具。因此将Go语言程序作为输入数据，让我们语法树这个维度重新审视Go语言程序，我们将得到创建Go语言本身的技术。Go语法树由标准库的go/ast包定义，它是在go/token包定义的词法基础只是抽象的语法树结构。本书简单介绍语法树相关包的使用（出版社已经约稿出版本书，并在开源版本的基础之上增加了语义信息、SSA形式、LLVM和凹语言等内容，因为出版社版权问题不方便全部公开新增内容）。<br><a href="https://github.com/chai2010/go-ast-book">领取地址</a></p></blockquote><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_18.png" /></p><p align="center">《Go语言101》</p>   <blockquote><p>Go语言101是一本侧重于Go语言语法语义以及运行时相关知识点的编程解释和指导书。 此书旨在尽可能地帮助Go程序员更深更全面地理解Go语言。 此书也搜集了Go语言和Go编程中的很多细节。 此书同时适合Go初学者和有一定经验的Go程序员阅读。<br><a href="https://github.com/golang101/golang101">领取地址</a></p></blockquote><h3 id="C-和-C"><a href="#C-和-C" class="headerlink" title="C 和 C++"></a>C 和 C++</h3><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_15.png" /></p><p align="center">《C/C++面向WebAssembly编程》</p>  <blockquote><p>适读人群 ：本书适合从事高性能Web前端开发、跨语言Web应用开发的技术人员学习参考，也可以作为WebAssembly标准参考手册随时查阅。<br>作为一种新颖的网页前端技术，WebAssembly的发展日新月异。本书基于已受浏览器普遍支持的WebAssembly极小可用特征集，致力于通过简单易懂的方式，从使用方法到虚拟机设计，讲解WebAssembly的运行原理。极小可用特征集只是快速迭代的起点，SIMD、多线程等更多特性将逐渐被添加到WebAssembly标准中。<br><a href="https://github.com/3dgen/cppwasm-book">领取地址</a></p></blockquote><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_16.jpeg" /></p><p align="center">《C++ Concurrency in Action》</p>  <blockquote><p>作者为对《C++ Concurrency in Action》的中文翻译。本书是基于C++11新标准的并发和多线程编程深度指南。从std::thread、std::mutex、std::future和std::async等基础类的使用，到内存模型和原子操作、基于锁和无锁数据结构的构建，再扩展到并行算法、线程管理，最后还介绍了多线程代码的测试工作。本书的附录部分还对C++11新语言特性中与多线程相关的项目进行了简要的介绍，并提供了C++11线程库的完整参考。本书适合于需要深入了解C++多线程开发的读者，以及使用C++进行各类软件开发的开发人员、测试人员。对于使用第三方线程库的读者，也可以从本书后面的章节中了解到相关的指引和技巧。同时，本书还可以作为C++11线程库的参考工具书。<br><a href="https://github.com/xiaoweiChen/Cpp_Concurrency_In_Action">领取地址</a></p></blockquote><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_5.png" /></p><p align="center">《BuildYourOwnLisp》</p> <blockquote><p>在本书中，你将在学习 C 语言的同时学会编写你自己的编程语言——一个 1000 行左右代码的简单 Lisp。不过我们并不是从零开始编写的，在代码中我用到了一个外部的库来完成一些初始化的工作。但是剩下的最重要的部分都是我们一行一行编写的，而且在本书结束时，你将会拥有一个属于自己的“麻雀虽小，五脏俱全”的 Lisp。<br>很多人非常想学习 C 语言，但却无从下手。现在大可不必担心了。如果你能坚持看完本书，我敢保证，至少你将拥有一个非常酷的新语言可以把玩，说不定还能成为一个熟练的 C 程序员呢！<br><a href="https://ksco.gitbooks.io/build-your-own-lisp/content">领取地址</a></p></blockquote><h3 id="Istio"><a href="#Istio" class="headerlink" title="Istio"></a>Istio</h3><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_8.jpg" /></p><p align="center">《Istio 服务网格进阶实战》</p> <blockquote><p>Istio 是由 Google、IBM、Lyft 等共同开源的 Service Mesh（服务网格）框架，作为云原生时代下承 Kubernetes、上接 Serverless 架构的重要基础设施层，于 2017 年开始进入大众视野。<br>2018 年由蚂蚁金服发起成立了 ServiceMesher 社区，作为中国最早的一批研究和推广 Service Mesh 技术的开源社区决定整合社区资源，合作撰写一本开源的 Service Mesh 电子书以飨读者。<br><a href="https://github.com/servicemesher/istio-handbook">领取地址</a></p></blockquote><h3 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h3><p align="center">《Rust 程序设计语言（第二版 & 2018 edition）》</p> <blockquote><p>Rust 被证明是可用于大型的、拥有不同层次系统编程知识的开发者团队间协作的高效工具。底层代码中容易出现种种隐晦的 bug，在其他编程语言中，只能通过大量的测试和经验丰富的开发者细心的代码评审来捕获它们。在 Rust 中，编译器充当了守门员的角色，它拒绝编译存在这些难以捕获的 bug 的代码，这其中包括并发 bug。通过与编译器合作，团队将更多的时间聚焦在程序逻辑上，而不是追踪 bug。<br><a href="https://github.com/KaiserY/trpl-zh-cn">领取地址</a></p></blockquote><h3 id="英文书籍"><a href="#英文书籍" class="headerlink" title="英文书籍"></a>英文书籍</h3><p align="center">《Machine-Learning-Systems-Design》</p> <blockquote><p>一本关于机器学习系统设计的小册子附有练习题<br><a href="https://github.com/chiphuyen/machine-learning-systems-design">领取地址</a></p></blockquote><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_9.jpg" /></p><p align="center">《Front-End Developer Handbook 2019》</p> <blockquote><p>该书适合任何阶段的人用来了解前端开发实践的指南，它概述和讨论了前端工程的实践：如何学习前端、在 2019 年进行前端实践时应该使用哪些工具。<br><a href="https://frontendmasters.com/books/front-end-handbook/2019/#1">领取地址</a></p></blockquote><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_1.jpg" /></p><p align="center">《Java 编程思想》</p> <blockquote><p>《计算机科学丛书：Java编程思想（第4版）》赢得了全球程序员的广泛赞誉，即使是晦涩的概念，在BruceEckel的文字亲和力和小而直接的编程示例面前也会化解于无形。从Java的基础语法到高级特性（深入的面向对象概念、多线程、自动项目构建、单元测试和调试等），本书都能逐步指导你轻松掌握。Bruce Eckel，是MindView公司的总裁，该公司向客户提供软件咨询和培训。他是C++标准委员会拥有表决权的成员之一，拥有应用物理学学士和计算机工程硕士学位。除本书外，他还是《C++编程思想》的作者，并与人合著了《C++编程思想第2卷》。<br>关注公众号【fulade_me】<br>回复关键字：<strong>Java4</strong></p></blockquote><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_4.png" /></p><p align="center">《JavaScript 20 年》</p> <blockquote><p>本书由 JavaScript 之父 Brendan Eich 与 ES6 规范首席作者 Allen Wirfs-Brock 联合编写，详细记载和解读了自 1995 年语言诞生到 2015 年 ES6 规范制定为止，共计 20 年的 JavaScript 语言演化历程。全书不仅讲解了大量语言技术细节层面的演进，更复盘了更高层面上规范制定与标准博弈中的历史成败，是一部讲述人类如何在商业与技术上的竞争合作中促进产业发展的故事。这个故事相当漫长而复杂。全文分为四个部分，每部分都对应 JavaScript 演化历程中的一个主要阶段。各部分之间还有一段简短的插曲，介绍彼时的开发者们是如何看待与使用 JavaScript 的。<br>关注公众号:【fulade_me】<br>回复关键字：<strong>JavaScript</strong></p></blockquote><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>protoc 同时编译多个.protoc文件</title>
      <link href="tips-command-line-protoc-5.html"/>
      <url>tips-command-line-protoc-5.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h5 id="官方的示例"><a href="#官方的示例" class="headerlink" title="官方的示例"></a>官方的示例</h5><p>只是编译一个文件的命令行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --proto_path=IMPORT_PATH --cpp_out=DST_DIR --java_out=DST_DIR --python_out=DST_DIR --go_out=DST_DIR --ruby_out=DST_DIR --objc_out=DST_DIR --csharp_out=DST_DIR path/to/file.proto</span><br></pre></td></tr></table></figure><p>我们想要编译同时编译多个文件<br>只需要把<code>path/to/file.proto</code>改为<code>path/to/*.proto</code> 即可。</p><h5 id="同时编译多个示例："><a href="#同时编译多个示例：" class="headerlink" title="同时编译多个示例："></a>同时编译多个示例：</h5><p>此示例只是编译了<code>objc</code>代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --proto_path=/Users/Demo/Desktop/Demo/proto --objc_out=./out /Users/Demo/Desktop/Demo/proto/*.proto</span><br></pre></td></tr></table></figure><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python 1-7】Python手把手教程之——详解列表List</title>
      <link href="python-list-7.html"/>
      <url>python-list-7.html</url>
      
        <content type="html"><![CDATA[<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)  </p><p>列表，在其他语言中又被称为<strong>数组</strong>，是由一系列按特定顺序排列的元素组成。你可以创建包含字母表中所有字母、数字0~9或所有家庭成员姓名的列表。你也可以创建几个列表，把这几个列表又放在一个列表内。<br>在Python中，用方括号<code>[]</code>来表示列表，并用逗号来分隔其中的元素。下面是一个简单的列表示例，这个列表包含几种常见的水果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>,<span class="string">&#x27;Orange&#x27;</span>]</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>,<span class="string">&#x27;Orange&#x27;</span>]</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="访问列表数据"><a href="#访问列表数据" class="headerlink" title="访问列表数据"></a>访问列表数据</h4><p>列表是有序的数据集合，每一个元素都有一个位置参数。比如上面的<code>fruits</code>列表里面，其中<code>Apple</code>的位置参数是<code>0</code>，<code>Banana</code>位置参数是<code>1</code>。要访问列表元素，可指出列表的名称，再指出元素的索引，并将其放在方括号内。<br>例如，下面的代码从列表<code>fruits</code>中选出第一种水果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>,<span class="string">&#x27;Orange&#x27;</span>]</span><br><span class="line">print(fruits[<span class="number">0</span>])</span><br><span class="line">Apple</span><br></pre></td></tr></table></figure><h4 id="索引是从0开始的"><a href="#索引是从0开始的" class="headerlink" title="索引是从0开始的"></a>索引是从0开始的</h4><p>所有的列表位置参数都是从<code>0</code>开始的而不是从1开始的，对于初学者，这个一定要记牢。如果在编码过程中发现取出的元素跟自己预期的不一样，请看看你是否犯了这种简单的错误。<br>第二个列表元素的索引为1。根据这种简单的计数方式，要访问列表的任何元素，都可将其位置减<code>1</code>，并将结果作为索引。例如，要访问第4个列表元素，可使用索引<code>3</code>。<br>下面的代码访问索引<code>1</code>和<code>3</code>处的水果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>,<span class="string">&#x27;Orange&#x27;</span>]</span><br><span class="line">print(fruits[<span class="number">1</span>])</span><br><span class="line">print(fruits[<span class="number">3</span>])</span><br><span class="line">Banana</span><br><span class="line">Orange</span><br></pre></td></tr></table></figure><p>Python为访问最后一个列表元素提供了一种特殊语法。通过将索引指定为<code>-1</code>，可让Python返回最后一个列表元素:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>,<span class="string">&#x27;Orange&#x27;</span>]</span><br><span class="line">print(fruits[-<span class="number">1</span>])</span><br><span class="line">Orange</span><br></pre></td></tr></table></figure><p>这里返回的是<code>Orange</code>。这种语法很有用，因为你经常需要在不知道列表长度的情况下访问最后的元素。<br>这种约定也适用于其他负数索引，例如：索引<code>-2</code>返回倒数第二个列表元素， 索引<code>-3</code>返回倒数第三个列表元素，以此类推。</p><h4 id="修改列表元素"><a href="#修改列表元素" class="headerlink" title="修改列表元素"></a>修改列表元素</h4><p>要修改列表元素，可指定列表名和要修改的元素的索引，再指定该元素的新值。<br>例如，假设有一个水果列表，其中的第一个元素为<code>Apple</code>，如何修改它的值呢?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>,<span class="string">&#x27;Orange&#x27;</span>]</span><br><span class="line">print(fruits[<span class="number">0</span>])</span><br><span class="line">print(fruits)</span><br><span class="line">Apple</span><br><span class="line">[<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>,<span class="string">&#x27;Orange&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始把第一个元素修改为 Cherry</span></span><br><span class="line">fruits[<span class="number">0</span>] = <span class="string">&#x27;Cherry&#x27;</span></span><br><span class="line">print(fruits[<span class="number">0</span>])</span><br><span class="line">print(fruits)</span><br><span class="line">Cherry</span><br><span class="line">[<span class="string">&#x27;Cherry&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>,<span class="string">&#x27;Orange&#x27;</span>]</span><br></pre></td></tr></table></figure><h4 id="在列表中添加元素"><a href="#在列表中添加元素" class="headerlink" title="在列表中添加元素"></a>在列表中添加元素</h4><p>你可能出于很多原因要在列表中添加新元素。比如商场里又新增加了一种水果，需要在<code>fruits</code>里面中再新增一种水果。Python提供了多种在既有列表中添加新数据的方式。<br><strong>1.在列表末尾添加元素</strong><br>在列表中添加新元素时，最简单的方式是将元素附加到列表末尾。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>,<span class="string">&#x27;Orange&#x27;</span>]</span><br><span class="line">print(fruits)</span><br><span class="line">fruits.append(<span class="string">&#x27;Cherry&#x27;</span>)</span><br><span class="line">print(fruits)</span><br></pre></td></tr></table></figure><p>方法<code>append()</code>将元素<code>Cherry</code>添加到了列表末尾，而不影响列表中的其他所有元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>,<span class="string">&#x27;Orange&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>,<span class="string">&#x27;Orange&#x27;</span>,<span class="string">&#x27;Cherry&#x27;</span>]</span><br></pre></td></tr></table></figure><p><code>append()</code>可以很好的满足我们动态创建数组的需求。例如，我们可以先创建一个空的列表，在使用一系列的<code>append()</code>语句来动态的添加元素。<br>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fruits = []</span><br><span class="line">fruits.append(<span class="string">&#x27;Apple&#x27;</span>)</span><br><span class="line">fruits.append(<span class="string">&#x27;Banana&#x27;</span>)</span><br><span class="line">fruits.append(<span class="string">&#x27;Pear&#x27;</span>)</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>]</span><br></pre></td></tr></table></figure><p>这种创建方式比较常见，因为很多时候，我们在代码的执行过程中才会知道哪些元素需要添加到列表中，哪些元素不需要添加。<br><strong>2.在列表中插入元素</strong>  </p><p>使用方法<code>insert()</code>可在列表的任何位置添加新元素。但是，你需要指定新元素的索引和值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>]</span><br><span class="line">fruits.insert(<span class="number">0</span>,<span class="string">&#x27;Orange&#x27;</span>)</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;Orange&#x27;</span>,<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>]</span><br></pre></td></tr></table></figure><p>在该实例中，<code>Orange</code>被插入到了索引为<code>0</code>的这个位置。这种操作会使列表内的其他的每个元素都右移一个位置。<br>需要注意的是：插入数据的索引不能超过列表当前最大的索引值，如果我们执行<code>fruits.insert(10,&#39;Orange&#39;)</code>就会报错。你可以试一下。</p><h4 id="从列表中删除元素"><a href="#从列表中删除元素" class="headerlink" title="从列表中删除元素"></a>从列表中删除元素</h4><p>我们经常需要从列表中删除一个元素，比如说有<code>Apple</code>这种水果因为缺货需要下架了，我们需要将<code>Apple</code>从列表中移除掉。你可以根据位置或值来删除列表中的元素。<br><strong>1.使用del语句删除元素</strong><br>如果知道要删除的元素在列表中的位置，可直接使用<code>del</code>语句。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>]</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> fruits[<span class="number">0</span>]</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>]</span><br></pre></td></tr></table></figure><p>使用<code>del</code>可删除任何位置处的列表元素，条件是知道其索引。下例演示了如何删除<code>fruits</code>列表中的第二个元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>]</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> fruits[<span class="number">1</span>]</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>]</span><br></pre></td></tr></table></figure><p>从输出来看，第二个元素已经被删除了。<br><strong>2.使用方法pop()删除元素</strong><br>有时候，你要将元素从列表中删除，并接着使用它的值。比如你下架了某种水果，需要把这种水果放入到明天的采购列表中。<br>方法<code>pop()</code>可删除列表末尾的元素，并让你能够接着使用它。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>]</span><br><span class="line">print(fruits)</span><br><span class="line">poped_fruit = fruits.pop()</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Banana&#x27;</span>]</span><br><span class="line">print(poped_fruit)</span><br><span class="line">Pear</span><br></pre></td></tr></table></figure><p>执行<code>pop()</code>方法后，原数组最后一个元素被移除掉且最后一个元素作为返回值被返回。<br><strong>3.pop列表中任何位置处的元素</strong><br>想必你已经猜到了，我们只需要在<code>pop()</code>方法内传入想移除的元素索引就可以。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>]</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Banana&#x27;</span>, <span class="string">&#x27;Pear&#x27;</span>]</span><br><span class="line">first_fruit = fruits.pop(<span class="number">0</span>)</span><br><span class="line">print(first_fruit)</span><br><span class="line">Apple</span><br></pre></td></tr></table></figure><p>别忘了，每当你使用pop()时，被弹出的元素就不再在列表中了。<br>如果你不确定该使用del语句还是<code>pop()</code>方法，下面是一个简单的判断标准: 如果你要从列表中删除一个元素，且不再以任何方式使用它，就使用<code>del</code>语句，如果你要在删除元素后还能继续使用它，就使用方法<code>pop()</code>。<br><strong>4.根据值删除元素</strong><br>有时候，我们并不知道要从列表中删除的值所处的位置。如果你只知道要删除的元素的值，可使用<code>remove()</code>方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>]</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Banana&#x27;</span>, <span class="string">&#x27;Pear&#x27;</span>]</span><br><span class="line">fruits.remove(<span class="string">&#x27;Apple&#x27;</span>)</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;Banana&#x27;</span>, <span class="string">&#x27;Pear&#x27;</span>]</span><br></pre></td></tr></table></figure><p>方法<code>remove()</code>只删除在列表中出现的第一个指定的值。也就是说假如<code>Apple</code>在<code>fruits</code>列表中出现了多次，调用<code>remove()</code>方法，只会删除第一个<code>Apple</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>,<span class="string">&#x27;Apple&#x27;</span>]</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Banana&#x27;</span>, <span class="string">&#x27;Pear&#x27;</span>,<span class="string">&#x27;Apple&#x27;</span>]</span><br><span class="line">fruits.remove(<span class="string">&#x27;Apple&#x27;</span>)</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;Banana&#x27;</span>, <span class="string">&#x27;Pear&#x27;</span>,<span class="string">&#x27;Apple&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="整合列表"><a href="#整合列表" class="headerlink" title="整合列表"></a>整合列表</h3><p>在我们创建的列表中，元素的排列顺序常常是无法预测的。因为我们并非总能控制用户提供数据的顺序。我们又经常需要以特定的顺序呈现信息。有时候，你希望保留列表元素最初的排列顺序，而有时候又需要调整排列顺序。Python提供了很多组织列表的方式，可根据具体情况选用。</p><h4 id="使用方法sort-对列表进行永久性排序"><a href="#使用方法sort-对列表进行永久性排序" class="headerlink" title="使用方法sort()对列表进行永久性排序"></a>使用方法sort()对列表进行永久性排序</h4><p>Python方法<code>sort()</code>让你能够轻松地对列表进行排序。假设你有一个水果列表，并要让其中的水果按字母顺序排列。为简化这项任务，我们假设该列表中的所有值都是小写的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;pear&#x27;</span>,<span class="string">&#x27;banana&#x27;</span>,<span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line">fruits.sort()</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>]</span><br></pre></td></tr></table></figure><p>方法<code>sort()</code>永久性地修改了列表元素的排列顺序。现在，<code>fruits</code>是按字母顺序排列的，再也无法恢复到原来的排列顺序。<br>我们还可以按与字母顺序相反的顺序排列列表元素，为此，只需向<code>sort()</code>方法传递参数<code>reverse=True</code>即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fruits.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br></pre></td></tr></table></figure><h4 id="使用函数sorted-对列表进行临时排序"><a href="#使用函数sorted-对列表进行临时排序" class="headerlink" title="使用函数sorted()对列表进行临时排序"></a>使用函数sorted()对列表进行临时排序</h4><p>要保留列表元素原来的排列顺序，同时以特定的顺序呈现它们，可使用函数<code>sorted()</code>。函数<code>sorted()</code>让你能够按特定顺序显示列表元素，同时不影响它们在列表中的原始排列顺序。下面尝试对<code>fruits</code>列表调用这个函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;pear&#x27;</span>,<span class="string">&#x27;banana&#x27;</span>,<span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line">print(<span class="built_in">sorted</span>(fruits))</span><br><span class="line">[<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>]</span><br><span class="line"><span class="comment"># 再一次输出 fruits</span></span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br></pre></td></tr></table></figure><p>注意，调用函数<code>sorted()</code>后，列表元素的排列顺序并没有变。如果你要按与字母顺序相反的顺序显示列表，也可向函数<code>sorted()</code>传递参数<code>reverse=True</code>。<br>在并非所有的值都是小写时，按字母顺序排列列表要复杂些，这个问题我们后面再详细解答。</p><h4 id="倒序输出列表"><a href="#倒序输出列表" class="headerlink" title="倒序输出列表"></a>倒序输出列表</h4><p>要反转列表元素的排列顺序，可使用方法<code>reverse()</code>。假设<code>fruist</code>列表是按购买时间排列的，可轻松地按相反的顺序排列其中的水果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;pear&#x27;</span>,<span class="string">&#x27;banana&#x27;</span>,<span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line">fruits.reverse()</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>]</span><br></pre></td></tr></table></figure><p><code>reverse()</code>不是指按与字母顺序相反的顺序排列列表元素，而只是<strong>反转</strong>列表元素的排列顺序。<br>方法<code>reverse()</code>永久性地修改列表元素的排列顺序，但可随时恢复到原来的排列顺序，为此 只需对列表再次调用reverse()即可</p><h4 id="列表的长度"><a href="#列表的长度" class="headerlink" title="列表的长度"></a>列表的长度</h4><p>使用函数<code>len()</code>可快速获悉列表的长度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fruits = [<span class="string">&#x27;pear&#x27;</span>,<span class="string">&#x27;banana&#x27;</span>,<span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line"><span class="built_in">len</span>(fruits)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>获取列表的长度在开发过程中很有用，比如我们利用<code>len()</code>方法一下就可以获取到当前有多少种水果正在销售。</p><h4 id="动手试一试"><a href="#动手试一试" class="headerlink" title="动手试一试"></a>动手试一试</h4><blockquote><p>7-1 将一些朋友的姓名存储在一个列表中，并将其命名为 names。依次访问该列表中的每个元素，从而将每个朋友的姓名都打印出来。<br>7-2 嘉宾名单: 如果你可以邀请任何人一起共进晚餐(无论是在世的还是故去的)，你会邀请哪些人？请创建一个列表，其中包含至少 3 个你想邀请的人，然后，打印列表。<br>7-3 修改嘉宾名单:你刚得知有位嘉宾无法赴约，因此需要另外邀请一位嘉宾。修改嘉宾名单，将无法赴约的嘉宾的姓名替换为新邀请的嘉宾的姓名。<br>然后再一次打印这个列表。<br>7-4 添加嘉宾:你刚找到了一个更大的餐桌，可容纳更多的嘉宾。请想想你还想邀请哪三位嘉宾。<br>使用 insert()将一位新嘉宾添加到名单开头。<br>使用 insert()将另一位新嘉宾添加到名单中间。<br>使用 append()将最后一位新嘉宾添加到名单末尾。<br>7-5 缩减名单: 你刚得知新购买的餐桌无法及时送达，因此只能邀请两位嘉宾。  使用pop()不断地删除名单中的嘉宾，直到只有两位嘉宾为止。每次从名单中弹出一位嘉宾时，都打印一下。<br>7-7 放眼世界: 想出至少 5 个你渴望去旅游的地方。将这些地方存储在一个列表中，并确保其中的元素不是按字母顺序排列的。按原始排列顺序打印该列表。不要考虑输出是否整洁的问题，只管打印原始Python 列表。<br>使用 sorted()按字母顺序打印这个列表，同时不要修改它。再次打印该列表，核实排列顺序未变。<br>使用 sorted()按与字母顺序相反的顺序打印这个列表，同时不要修改它。再次打印该列表，核实排列顺序未变。<br>使用 reverse()修改列表元素的排列顺序。打印该列表，核实排列顺序确实变了。<br>使用 reverse()再次修改列表元素的排列顺序。打印该列表，核实已恢复到原来的排列顺序。<br>使用 sort()修改该列表，使其元素按字母顺序排列。打印该列表，核实排列顺序确实变了。<br>使用 sort()修改该列表，使其元素按与字母顺序相反的顺序排列。打印该列表，核实排列顺序确实变了。</p></blockquote><p>想查看作业答案可以去<a href="https://github.com/Johnson8888/learn_python">我的Githu仓库</a></p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>是时候来薅京东的羊毛了，自动化签到脚本！</title>
      <link href="tips-jd-auto-sigh-2.html"/>
      <url>tips-jd-auto-sigh-2.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)<br><a href="http://fulade.me/tips-jd-auto-sigh-2.html">文章首发地址</a></p><blockquote><p>双十一刚刚过，相信很多小伙伴也都剁手了。今年电商平台同样给出了很多优惠。有些优惠，比如红包，是靠运气来获得的，但是还有一些优惠是靠长期坚持才能获得。比如：签到、东东萌宠。每天都能坚持签到固然很棒，但是如果有脚本可以自动签到，那岂不是更美？</p></blockquote><a id="more"></a><p><a href="https://github.com/Johnson8888/jd_sign_bot">自动签到脚本</a>此脚本涵盖了目前京90%以上的签到任务，我们只需要简单配置，每天定时触发，就可以签到，领奖品了。而且都是<strong>免费的</strong>。</p><h5 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h5><ul><li>node.js</li><li>Server酱(可选)</li></ul><h5 id="获取京东Cookie"><a href="#获取京东Cookie" class="headerlink" title="获取京东Cookie"></a>获取京东Cookie</h5><p>这里以<code>Chrome</code>浏览器为例，<code>Edge</code>、<code>360浏览器</code>、<code>QQ浏览器</code>同样支持。</p><ul><li>打开Chrome浏览的隐私模式，输入<a href="https://m.jd.com/">https://m.jd.com/</a>。</li><li>按下键盘上的<code>F12</code>进入调试模式，选择手机模式。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_auto_sign_device.jpg" alt="2020_11_13_auto_sign_device"><br>如果没有登录就使用<code>手机验证码</code>方式登录(已登录，可忽略)，使用验证码登录获取的<code>cookie</code>有效时长30天左右，存活时间更长。</li><li>登录成功后，点击<code>Network</code><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_auto_sign_network.png" alt="2020_11_13_auto_sign_network"></li></ul><p>然后点击箭头所指的这个按钮清理一下，因为网络请求太多了，不方便查看。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_auto_sign_clear.png" alt="2020_11_13_auto_sign_clear"><br>清理完了之后，点击一下<code>我的</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_auto_sign_gif.png" alt="2020_11_13_auto_sign_gif"><br>这个时候我们找到一个<code>log.gif?</code>开头的请求，点击它，就可以看到<code>cookie</code>字段了。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_auto_sign_cookie.png" alt="2020_11_13_auto_sign_cookie"></p><ul><li>这样复制出来的cookie比较长，我们只需要<code>pt_pin=xxxx;</code>和 <code>pt_key=xxxx;</code>部分的内容即可(注:英文引号<code>;</code>是必要的)。<br>可以用下面的脚本，直接在<code>console</code>里面输入下面脚本按<code>enter</code>回车键。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CV = <span class="string">&#x27;单引号里面放上面拿到的cookie&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> CookieValue = CV.match(<span class="regexp">/pt_pin=.+?;/</span>) + CV.match(<span class="regexp">/pt_key=.+?;/</span>);</span><br><span class="line">copy(CookieValue);</span><br></pre></td></tr></table></figure>这样子整理出关键的的cookie已经在你的剪贴板上，可直接粘贴。<br>我们先把它保存好，下面的步骤要用到。</li></ul><h5 id="配置-Server酱"><a href="#配置-Server酱" class="headerlink" title="配置 Server酱"></a>配置 Server酱</h5><p><a href="http://sc.ftqq.com/3.version">Server酱</a>是一个免费的，可以推送消息到我们微信的服务。<br>推送服务可以帮助我们每天观察签到的情况，如果出错了，可以及时调整。如果有的小伙伴不需要，可忽略这个步骤，直接进入下一步。</p><ul><li>打开主页 <a href="http://sc.ftqq.com/3.version">http://sc.ftqq.com/3.version</a>，点击右上角<code>登入</code><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_server_jiang_main_page.jpg" alt="2020_11_13_server_jiang_main_page"></li><li>使用Github 授权，登录。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_server_jiang_login.jpg" alt="2020_11_13_server_jiang_login"><br>输入账号密码即可。</li><li>登录成功后点击<code>微信推送</code>并扫描二维码绑定微信<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_server_jiang_wechat.jpg" alt="2020_11_13_server_jiang_wechat"><br>使用手机打开微信，扫描屏幕上的二维码，如果未关注，先关注，然后再绑定即可。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_server_jiang_qrcode.jpg" alt="2020_11_13_server_jiang_qrcode"></li><li>绑定成功后，点击右上方的<code>发送消息</code>链接，就可以看到你自己的 <code>key</code>值，保存下来，后面会用到。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_server_jiang_test.jpg" alt="2020_11_13_server_jiang_test"><br>当然你也可以在下面的<code>在线发送工具</code>测试推送是否生效。</li></ul><h5 id="配置本地代码"><a href="#配置本地代码" class="headerlink" title="配置本地代码"></a>配置本地代码</h5><ul><li><p>使用<code>git clone</code>命令将<a href="https://github.com/Johnson8888/jd_sign_bot">https://github.com/Johnson8888/jd_sign_bot</a>代码下载下来。</p></li><li><p>下载完成后，我们需要安装项目所需要的依赖。使用命令行工具(Mac下使用<code>Termainal</code>,Windows下使用<code>PowerShell</code>)进入到<code>jd_sign_bot</code>文件内。在命令行内输入 <code>npm install --dependencies</code>，等待运行完成。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_npm_install.png" alt="2020_11_13_npm_install"><br>此时，项目文件夹内会多出一个 <code>node_modules</code>文件夹。</p></li><li><p>配置Cookies<br>打开文件内的<code>JD_DailyBonus.js</code>文件，修改<code>Key</code>参数为刚刚获取到的cookies<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_input_server_jiang.png" alt="2020_11_13_input_server_jiang"></p></li><li><p>配置Server酱<br>打开文件内的<code>app.js</code>文件，修改<code>serverJ</code>参数为刚刚获取到的Server酱的key<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_input_cookies.png" alt="2020_11_13_input_cookies"></p></li></ul><h5 id="执行签到"><a href="#执行签到" class="headerlink" title="执行签到"></a>执行签到</h5><p>进入到<code>jd_sign_hot</code>文件夹下，执行 <code>node app.js</code>即可签到！<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_auto_sign_exec.jpg" alt="2020_11_13_auto_sign_exec"><br>此时我们的脚本在本地就已经部署好了，如果你想更编辑，可以把代码部署到云服务器上，这样就不需要每天点击触发了。<br>或者你也可以部署在自己的服务器上，每天定时执行。</p><h4 id="你也可以-将脚本部署在腾讯云-·-云函数-上"><a href="#你也可以-将脚本部署在腾讯云-·-云函数-上" class="headerlink" title="你也可以 将脚本部署在腾讯云 · 云函数 上"></a>你也可以 将脚本部署在腾讯云 · 云函数 上</h4><p>去到<a href="https://console.cloud.tencent.com/scf/index">腾讯云函数地址</a>，如果没有开通此服务的顺手开一下就可以了。</p><ul><li><p>单击左侧导航栏函数服务，进入<strong>函数服务</strong>页面。 在页面上方选择一个地域，最好选择离你常用地区近点的，不至于导致账号异常。单击<strong>新建</strong>。如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_tengxun_clound.jpg" alt="2020_11_13_tengxun_clound"></p></li><li><p>在<strong>新建函数</strong>页面填写函数基础信息，单击下一步。如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_tengxunyun_input.png" alt="2020_11_13_tengxunyun_input"></p></li><li><p>函数名称：可以自定义，比如为<code>jd_sign</code>。 运行环境：选择 <code>Nodejs 12.16</code>。 创建方式：选择 <code>空白函数</code>。<br>确保环境为<code>Nodejs 12.16</code>，执行方法改为：<code>index.main_handler</code>，提交方式建议选本地文件夹。</p></li><li><p>然后将刚才下载并配置好的文件夹<code>jd_sign_bot</code>上传上来。（记得node_modules文件夹一并上传），完了后点击下面的高级设置。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_tengxunyun_input_1.png" alt="2020_11_13_tengxunyun_input_1"></p></li><li><p>内存用不了太大，64MB就够了（64M内存，免费时长6,400,000秒，内存与免费时长大致关系可以参看云函数官方说明），超时时间改为最大的900秒，然后点击最下面的完成。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_tengxunyun_input_2.png" alt="2020_11_13_tengxunyun_input_3"></p><ul><li>点击刚创建的函数</li></ul><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_tengxunyun_input_3.png" alt="2020_11_13_tengxunyun_input_3"></p><p>点击<code>创建触发器</code></p><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_tengxunyun_input_4.png" alt="2020_11_13_tengxunyun_input_4"></p><p>比如我填写的是 <code>0 45 8 * * * *</code>，每天上午8点45触发一次。<br>腾讯云提供了相关配置<a href="https://cloud.tencent.com/document/product/583/9708#cron-.E8.A1.A8.E8.BE.BE.E5.BC.8F">Cron的文档</a>，也有第三方<a href="https://tool.lu/crontab/">测试工具</a>。</p><h5 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h5><p>我们打开刚才创建的云函数，点击<code>保存并测试</code>，等过1分钟左右手机上收到推送，那我们的配置就是成功的。<br>如果没有收到推送，可以点击<code>日志查看</code>排查问题。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_tengxun_cloud_test.png" alt="2020_11_13_tengxun_cloud_test"></p><p>如果你不喜欢腾讯云的服务<br>我们可以参考<a href="https://ruicky.me/2020/06/05/jd-sign/">ruicky大神的博客</a>，将脚本部署在Github Actions上面也是也可以的。</p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 1-9】Flutter教程Dart语言——函数和匿名函数</title>
      <link href="dart-functions-1-9.html"/>
      <url>dart-functions-1-9.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h4><blockquote><p>Dart 同样也是一种面向对象的语音。所以即便函数也是一个对象。类型为 <code>Function</code>，这意味着函数可做作为变量，也也可以作为函数的参数。</p></blockquote><a id="more"></a><p>下面是定义一个函数的例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isEmpty(<span class="built_in">List</span> aList) &#123;</span><br><span class="line">  <span class="keyword">return</span> aList.length == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了规范其实我们需要在函数的头部声明一下返回值类型，当然如果不声明也可以运行，</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isEmpty(<span class="built_in">List</span> aList) &#123;</span><br><span class="line">  <span class="keyword">return</span> aList.length == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果函数体内只包含一个表达式，你可以使用简写语法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isEmpty(<span class="built_in">List</span> aList) =&gt; aList == <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p> <code>=&gt;</code> 表达的 是 <code>&#123; return 表达式; &#125;</code> 的简写，有时<code>=&gt;</code>也称之为<strong>胖箭头语法</strong>。</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a><strong>参数</strong></h4><p>函数可以有两种形式的参数：<strong>必选参数</strong> 和 <strong>可选参数</strong>。必选参数定义在参数列表前面，可选参数一定是定义在必要参数后面。</p><h5 id="可选的命名参数"><a href="#可选的命名参数" class="headerlink" title="可选的命名参数"></a><strong>可选的命名参数</strong></h5><p>当你调用函数时，可以使用 参数名: 参数值 的形式来指定命名参数。例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enableFlags(bold: <span class="keyword">true</span>, hidden: <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>已命名的参数是可选参数了，除非他们被特别标记为 <code>required</code>。</p><p>定义函数时，使用 <code>&#123;param1, param2, …&#125;</code> 来指定命名参数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">设置 [bold] 和 [hidden] 标识……</span></span></span><br><span class="line"><span class="keyword">void</span> enableFlags(&#123;<span class="built_in">bool</span> bold, <span class="built_in">bool</span> hidden&#125;) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>虽然命名参数是可选参数的一种类型，但是你仍然可以使用 <code>@required</code> 注解来标识一个命名参数是必须的参数，此时调用者则必须为该参数提供一个值。例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Scrollbar(&#123;Key key, <span class="meta">@required</span> Widget child&#125;)</span><br></pre></td></tr></table></figure><p>如果调用者想要通过 <code>Scrollbar</code> 的构造函数构造一个 <code>Scrollbar</code> 对象而不提供 child 参数，则会导致编译错误。</p><h5 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a><strong>可选参数</strong></h5><p>使用 <code>[]</code> 将一系列参数包裹起来作为可选参数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">strings(<span class="built_in">String</span> s1, <span class="built_in">String</span> s2, [<span class="built_in">String</span> s3]) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">&#x27;<span class="subst">$s1</span> and <span class="subst">$s2</span>&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (s3 != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="string">&#x27;<span class="subst">$result</span> and <span class="subst">$s3</span>&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">print</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是不使用可选参数调用上述函数的示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strings(<span class="string">&quot;s1&quot;</span>, <span class="string">&quot;s2&quot;</span>);</span><br><span class="line">s1 and s2</span><br></pre></td></tr></table></figure><p>下面是使用可选参数调用上述函数的示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strings(<span class="string">&quot;s1&quot;</span>, <span class="string">&quot;s2&quot;</span>, <span class="string">&quot;s3&quot;</span>);</span><br><span class="line">s1 and s2 and s3</span><br></pre></td></tr></table></figure><h5 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a><strong>默认参数值</strong></h5><p>我们可以用 <code>=</code> 为函数的命名参数和可选参数定义默认值，默认值必须为编译时常量，没有指定默认值的情况下默认值为 <code>null</code>。</p><p>下面是设置可选参数默认值示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">设置 [bold] 和 [hidden] 标识……</span></span></span><br><span class="line"><span class="keyword">void</span> enableFlags(&#123;<span class="built_in">bool</span> bold = <span class="keyword">false</span>, <span class="built_in">bool</span> hidden = <span class="keyword">false</span>&#125;) &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bold 的值将为 true；而 hidden 将为 false。</span></span><br><span class="line">enableFlags(bold: <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>下一个示例 默认值：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">strings(<span class="built_in">String</span> s1, <span class="built_in">String</span> s2, [<span class="built_in">String</span> s3 = <span class="string">&#x27;this is s3&#x27;</span>, <span class="built_in">String</span> s4]) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">&#x27;<span class="subst">$s1</span> and <span class="subst">$s2</span>&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (s3 != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="string">&#x27;<span class="subst">$result</span> and <span class="subst">$s3</span>&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s4 != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="string">&#x27;<span class="subst">$result</span> and <span class="subst">$s4</span>&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">print</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">strings(<span class="string">&quot;s1&quot;</span>, <span class="string">&quot;s2&quot;</span>);</span><br><span class="line">s1 and s2 and <span class="keyword">this</span> <span class="keyword">is</span> s3</span><br></pre></td></tr></table></figure><h5 id="main-函数"><a href="#main-函数" class="headerlink" title="main() 函数"></a><strong>main() 函数</strong></h5><p>每个 <code>Dart</code> 程序都必须有一个 <code>main()</code> 顶级函数作为程序的入口，<code>main()</code> 函数返回值为 <code>void</code>。</p><p>下面是一个 Flutter 应用的 <code>main()</code> 函数示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MyApp());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a><strong>函数作为参数</strong></h5><p>可以将函数作为参数传递给另一个函数。例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> printElement(<span class="built_in">int</span> element) &#123;</span><br><span class="line">  <span class="built_in">print</span>(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 printElement 函数作为参数传递。</span></span><br><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">list.forEach(printElement);</span><br></pre></td></tr></table></figure><p>你也可以将函数赋值给一个变量，比如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loudify = (msg) =&gt; <span class="string">&#x27;!!! <span class="subst">$&#123;msg.toUpperCase()&#125;</span> !!!&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> result = loudify(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="built_in">print</span>(result);</span><br></pre></td></tr></table></figure><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a><strong>匿名函数</strong></h4><blockquote><p>大多数方法都是有名字的，比如 <code>main()</code> 或 <code>printElement()</code>。你可以创建一个没有名字的方法，称之为 <strong>匿名函数</strong>，其实匿名函数很常见，也有不同的叫法，在C++里面叫Lambda表达式，在Objective-C叫Block闭包。你可以将匿名方法赋值给一个变量然后使用它。</p></blockquote><p>匿名方法看起来与命名函数h类似，在括号之间可以定义参数，参数之间用逗号分割。</p><p>后面大括号中的内容则为函数体：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">([[类型] 参数[, …]]) &#123;</span><br><span class="line">  函数体;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面代码定义了只有一个参数 <code>item</code> 且没有参数类型的匿名方法。<code>List</code> 中的每个元素都会调用这个函数，打印元素位置和值的字符串：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="string">&#x27;apples&#x27;</span>, <span class="string">&#x27;bananas&#x27;</span>, <span class="string">&#x27;oranges&#x27;</span>];</span><br><span class="line">list.forEach((item) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$&#123;list.indexOf(item)&#125;</span>: <span class="subst">$item</span>&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果函数体内只有一行语句，你可以使用胖箭头缩写法。下面代码的运行结果，与上面代码的运行结果是一致的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(</span><br><span class="line">    (item) =&gt; <span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$&#123;list.indexOf(item)&#125;</span>: <span class="subst">$item</span>&#x27;</span>));</span><br></pre></td></tr></table></figure><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a><strong>变量作用域</strong></h4><p>变量的作用域在写代码的时候就确定了，大括号内定义的变量只能在大括号内访问，与 Java 类似。</p><p>下面是一个嵌套函数中变量在多个作用域中的示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> topLevel = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> insideMain = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> myFunction() &#123;</span><br><span class="line">    <span class="keyword">var</span> insideFunction = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> nestedFunction() &#123;</span><br><span class="line">      <span class="keyword">var</span> insideNestedFunction = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">assert</span>(topLevel);</span><br><span class="line">      <span class="keyword">assert</span>(insideMain);</span><br><span class="line">      <span class="keyword">assert</span>(insideFunction);</span><br><span class="line">      <span class="keyword">assert</span>(insideNestedFunction);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <code>nestedFunction()</code> 函数可以访问包括顶层变量在内的所有的变量。</p><p>返回值<br>所有的函数都有返回值。没有显示返回语句的函数最后一行默认为执行 <code>return null</code>;。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(foo() == <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>本文所有代码都已上传到<a href="https://github.com/Johnson8888/learn_flutter">Github</a></p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 1-8】Flutter教程Dart语言——控制语句</title>
      <link href="dart-control-flow-statements-1-8.html"/>
      <url>dart-control-flow-statements-1-8.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h5 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a><strong>控制语句</strong></h5><p>Dart语言的控制语句跟其他常见语言的控制语句是一样的，基本如下：</p><ul><li><strong>if 和 else</strong></li><li><strong>for 循环</strong></li><li><strong>while 和 do-while 循环</strong></li><li><strong>break 和 continue</strong></li><li><strong>switch 和 case</strong></li><li><strong>assert</strong></li></ul><a id="more"></a><!-- [文章首发地址](http://fulade.me/dart-control-flow-statements-1-8.html) --><h5 id="If-和-Else"><a href="#If-和-Else" class="headerlink" title="If 和 Else"></a><strong>If 和 Else</strong></h5><p>Dart 支持 <code>if - else</code> 语句，其中 <code>else</code> 是可选的，比如下面的例子。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;value 0&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;value 1&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;other value&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要遍历的对象实现了 <code>Iterable</code> 接口，则可以使用 <code>forEach()</code> 方法，如果不需要使用到索引，则使用 <code>forEach</code> 方法是一个非常好的选择：</p><blockquote><p><code>Iterable</code>接口实现了很多方法，比如说 <code>forEach()、any()、where()</code>等，这些方法可以大大精简我们的代码，减少代码量。  </p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> callbacks = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">  callbacks.add(() =&gt; <span class="built_in">print</span>(i));</span><br><span class="line">&#125;</span><br><span class="line">callbacks.forEach((c) =&gt; c());</span><br></pre></td></tr></table></figure><p>像 <code>List</code> 和 <code>Set</code> 等，我们同样可以使用 <code>for-in</code> 形式的 迭代：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> collection = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">in</span> collection) &#123;</span><br><span class="line">  <span class="built_in">print</span>(x); <span class="comment">// 1 2 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="While-和-Do-While"><a href="#While-和-Do-While" class="headerlink" title="While 和 Do-While"></a><strong>While 和 Do-While</strong></h5><p>while 循环会在执行循环体前先判断条件：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  i++;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;i = &quot;</span> + i.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>do-while</code> 循环则会先执行一遍循环体 再 判断条件：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  i++;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;i = &quot;</span> + i.toString());</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">10</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Break-和-Continue"><a href="#Break-和-Continue" class="headerlink" title="Break 和 Continue"></a><strong>Break 和 Continue</strong></h5><p>使用 <code>break</code> 可以中断循环：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;break now&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;i = &quot;</span> + i.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>continue</code> 可以跳过本次循环直接进入下一次循环：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;i = &quot;</span> + i.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 List实现了 Iterable 接口，则可以简单地使用下述写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0,1, 2, 3, 4, 5, 6, 7, 8, 9].where((i) &#x3D;&gt; i &gt; 5).forEach((i) &#123;</span><br><span class="line">  print(&quot;i &#x3D; &quot; + i.toString());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="Switch-和-Case"><a href="#Switch-和-Case" class="headerlink" title="Switch 和 Case"></a><strong>Switch 和 Case</strong></h5><p>Switch 语句在 Dart 中使用 <code>==</code> 来比较整数、字符串或编译时常量，比较的两个对象必须是同一个类型且不能是子类并且没有重写 <code>==</code> 操作符。 枚举类型非常适合在 Switch 语句中使用。<br>每一个 <code>case</code> 语句都必须有一个 <code>break</code> 语句，也可以通过 <code>continue、throw</code> 或者 <code>return</code> 来结束 <code>case</code> 语句。<br>当没有 <code>case</code> 语句匹配时，可以使用 <code>default</code> 子句来匹配这种情况：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> command = <span class="string">&#x27;OPEN&#x27;</span>;</span><br><span class="line"><span class="keyword">switch</span> (command) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;CLOSED&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;CLOSED&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;PENDING&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;PENDING&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;APPROVED&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;APPROVED&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;DENIED&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;DENIED&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;OPEN&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;OPEN&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;UNKNOW&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，<code>Dart</code> 支持空的 <code>case</code> 语句，如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> command = <span class="string">&#x27;CLOSED&#x27;</span>;</span><br><span class="line"><span class="keyword">switch</span> (command) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;CLOSED&#x27;</span>: <span class="comment">// case 语句为空时的 fall-through 形式。</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;NOW_CLOSED&#x27;</span>:</span><br><span class="line">    <span class="comment">// case 条件值为 CLOSED 和 NOW_CLOSED 时均会执行该语句。</span></span><br><span class="line">    <span class="built_in">print</span>(command);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="断言"><a href="#断言" class="headerlink" title="断言"></a><strong>断言</strong></h5><p>在开发过程中，可以在条件表达式为 <code>false</code> 时使用 <strong>assert</strong>， 来中断代码的执行，提示出错误。你可以在本文中找到大量使用 <code>assert</code> 的例子。下面是相关示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 确保变量值不为 null (Make sure the variable has a non-null value)</span></span><br><span class="line"><span class="keyword">assert</span>(text != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保变量值小于 100。</span></span><br><span class="line"><span class="keyword">assert</span>(number &lt; <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保这是一个 https 地址。</span></span><br><span class="line"><span class="keyword">assert</span>(urlString.startsWith(<span class="string">&#x27;https&#x27;</span>));</span><br><span class="line"><span class="keyword">assert</span> 的第二个参数可以为其添加一个字符串消息。</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(urlString.startsWith(<span class="string">&#x27;https&#x27;</span>),<span class="string">&#x27;URL (<span class="subst">$urlString</span>) should start with &quot;https&quot;.&#x27;</span>);</span><br></pre></td></tr></table></figure><p><code>assert</code> 的第一个参数可以是值为布尔值的任何表达式。如果表达式的值为<code>true</code>，则断言成功，继续执行。如果表达式的值为<code>false</code>，则断言失败，抛出一个 <code>AssertionError</code> 异常。</p><p><strong>注意：</strong><br>在生产环境代码中，断言会被忽略，与此同时传入 <code>assert</code> 的参数不被判断。</p><p>本文所有代码都已上传到<a href="https://github.com/Johnson8888/learn_flutter">Github</a></p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 1-7】Flutter教程Dart语言——变量</title>
      <link href="dart-variable-1-7.html"/>
      <url>dart-variable-1-7.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><blockquote><p>2011年10月10日的GOTO大会上，谷歌的两位工程师发布了“Dart”；Dart是一种全新的编程语言，旨在帮助开发者构建Web应用程序。Dart 1.0于2013年11月14日发布。我们日常开发Flutter使用的就是Dart语言，所以我们有必要了解一下Dart语言的使用方法。</p></blockquote><a id="more"></a><p><a href="http://fulade.me/dart-variable-1-7.html">文章首发地址</a></p><h4 id="类型安全的语言"><a href="#类型安全的语言" class="headerlink" title="类型安全的语言"></a><strong>类型安全的语言</strong></h4><p>Dart 语言是类型安全的语言，但是由于其支持类型推断，因此大多数变量不需要显式地指定类型：<br>例如</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">初始化一个字符串</span></span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Fulade&#x27;</span>;</span><br><span class="line"><span class="comment">/// <span class="markdown">Int类型</span></span></span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1995</span>;</span><br><span class="line"><span class="comment">/// <span class="markdown">浮点数类型</span></span></span><br><span class="line"><span class="keyword">var</span> antennaDiameter = <span class="number">3.7</span>;</span><br><span class="line"><span class="comment">/// <span class="markdown">数组</span></span></span><br><span class="line"><span class="keyword">var</span> list = [<span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;C++&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line"><span class="comment">/// <span class="markdown">字典类型</span></span></span><br><span class="line"><span class="keyword">var</span> image = &#123;</span><br><span class="line">  <span class="string">&#x27;tags&#x27;</span>: [<span class="string">&#x27;土星&#x27;</span>],</span><br><span class="line">  <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;//path/to/saturn.jpg&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h4><p>下面的示例代码将创建一个变量并将其初始化：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Fulade&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>变量仅存储对象的引用。</strong><br>这里名为 name 的变量存储了一个 <code>String</code> 类型对象的引用，<code>&#39;Fulade&#39;</code> 则是该对象的值。<br><code>name</code> 变量的类型被推断为 <code>String</code>，但是你可以为其指定类型。<br>如果一个对象的引用不局限于单一的类型，可以将其指定为 <code>Object</code> 或 <code>dynamic</code> 类型。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dynamic</span> name = <span class="string">&#x27;Bob&#x27;</span>;</span><br></pre></td></tr></table></figure><p>除此之外你也可以指定类型：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> name = <span class="string">&#x27;Bob&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a><strong>默认值</strong></h4><p>在 Dart 中，未初始化的变量拥有一个默认的初始化值：<code>null</code>。即便数字也是如此，因为在 Dart 中一切皆为对象，数字也不例外。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> lineCount;</span><br><span class="line"><span class="keyword">if</span>(lineCount == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;line is null&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Final-和-Const"><a href="#Final-和-Const" class="headerlink" title="Final 和 Const"></a><strong>Final 和 Const</strong></h5><p>如果你不想更改一个变量，可以使用关键字 <code>final</code> 或者 <code>const</code> 修饰变量，这两个关键字可以替代 <code>var</code> 关键字。<br><strong>需要注意的是：</strong><br><code>final</code> 变量只可以被赋值一次；<br><code>const</code> 变量是一个编译时常量。（<code>const</code> 变量同时也是 <code>final</code>）<br>被<code>final</code>修饰的变量在第一次使用的时候被初始化。<br>下面的示例中我们创建并设置两个 <code>final</code> 变量：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> name = <span class="string">&#x27;Bob&#x27;</span>; <span class="comment">// Without a type annotation</span></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">String</span> nickname = <span class="string">&#x27;Bobby&#x27;</span>;</span><br></pre></td></tr></table></figure><p>你不能修改一个 <code>final</code> 变量的值：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;Alice&#x27;</span>; <span class="comment">// Error: a final variable can only be set once.</span></span><br></pre></td></tr></table></figure><p>使用关键字 <code>const</code> 修饰变量表示该变量为 <strong>编译时常量</strong>。如果使用 <code>const</code> 修饰类中的变量，则必须加上 <code>static</code> 关键字，即 <code>static const</code>（注意：顺序不能颠倒）。在声明 <code>const</code> 变量时可以直接为其赋值，也可以使用其它的 <code>const</code> 变量为其赋值：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> i = <span class="number">10</span>; <span class="comment">// 直接赋值 [Unit of pressure (dynes/cm2)]</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">double</span> j = <span class="number">1.01325</span> * i; <span class="comment">// 利用其它 const 变量赋值 </span></span><br></pre></td></tr></table></figure><p>本文所有代码都已上传到<a href="https://github.com/Johnson8888/learn_flutter">Github</a></p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python 1-6】Python教程之——数字</title>
      <link href="python-number-1-6.html"/>
      <url>python-number-1-6.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>数字是一种用来表示数的书写符号：<br>中文数字写作三十七、卅七<br>罗马数字写作XXXVII<br>阿拉伯数字二进制写作100101</p></blockquote><p><a href="http://fulade.me/python-number-1-6.html">文章首发地址</a></p><p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a><strong>数字</strong></h4><p>在编程中，经常使用数字来记录游戏得分、表示可视化数据、存储Web应用信息等。Python 根据数字的用法以不同的方式处理它们。我们平时最常见的就是整数，下面就先来看看Python是如何管理整数的。</p><h5 id="整数"><a href="#整数" class="headerlink" title="整数"></a><strong>整数</strong></h5><p>在Python中，可对整数执行加<code>+</code>减<code>-</code>乘<code>*</code>除<code>/</code>运算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> + <span class="number">3</span> </span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> - <span class="number">2</span> </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> * <span class="number">3</span> </span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> / <span class="number">2</span> </span><br><span class="line"><span class="number">1.5</span></span><br></pre></td></tr></table></figure><p>在终端(命令行)会话中，Python直接返回运算结果。Python使用两个乘号表示乘方运算:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> ** <span class="number">2</span> </span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> ** <span class="number">3</span> </span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span> ** <span class="number">6</span> </span><br><span class="line"><span class="number">1000000</span></span><br></pre></td></tr></table></figure><p>Python还支持运算次序，因此你可在同一个表达式中使用多种运算。当然我们也可以使用括号来修改运算次序，让Python按你指定的次序执行运算，如下所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> + <span class="number">3</span>*<span class="number">4</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">2</span> + <span class="number">3</span>) * <span class="number">4</span> </span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><h5 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a><strong>浮点数</strong></h5><p>Python将带小数点的数字都称为浮点数。大多数编程语言都使用了这个术语，它指出了这样 一个事实:小数点可出现在数字的任何位置。<br>每种编程语言都须细心设计，以妥善地处理浮点数， 确保不管小数点出现在什么位置，数字的行为都是正常的。<br>从很大程度上说，使用浮点数时都无需考虑其行为。你只需输入要使用的数字，Python通常都会按你期望的方式处理它们:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0.1</span> + <span class="number">0.1</span></span><br><span class="line"><span class="number">0.2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0.2</span> + <span class="number">0.2</span> <span class="number">9</span> <span class="number">0.4</span></span><br><span class="line">&gt;&gt;&gt;<span class="number">2</span> * <span class="number">0.1</span></span><br><span class="line"><span class="number">0.2</span></span><br><span class="line">&gt;&gt;&gt;<span class="number">2</span> * <span class="number">0.2</span></span><br><span class="line"><span class="number">0.4</span></span><br></pre></td></tr></table></figure><p>但需要注意的是，结果包含的小数位数可能是不确定的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0.2</span> + <span class="number">0.1</span> </span><br><span class="line"><span class="number">0.30000000000000004</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> * <span class="number">0.1</span> </span><br><span class="line"><span class="number">0.30000000000000004</span></span><br></pre></td></tr></table></figure><p>所有语言都存在这种问题，没有什么可担心的。Python会尽力找到一种方式，以尽可能<strong>精确</strong>地表示结果，但鉴于计算机内部表示数字的方式，这在有些情况下很难。就现在而言，暂时忽略多余的小数位数即可。</p><h5 id="使用函数str-避免类型错误"><a href="#使用函数str-避免类型错误" class="headerlink" title="使用函数str()避免类型错误"></a><strong>使用函数str()避免类型错误</strong></h5><p>你经常需要在消息中使用变量的值。例如，假设你要祝别人生日快乐，可能会编写类似于下面的代码(将下面代码保存为<code>birthday.py</code>):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">23</span></span><br><span class="line">message = <span class="string">&quot;Happy &quot;</span> + age + <span class="string">&quot;rd Birthday!&quot;</span></span><br><span class="line">print(message)</span><br></pre></td></tr></table></figure><p>你可能认为，上述代码会打印一条简单的生日祝福语:<code>Happy 23rd birthday!</code>。但如果你运行这些代码，将发现它们会引发错误:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">&quot;birthday.py&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">message = <span class="string">&quot;Happy &quot;</span> + age + <span class="string">&quot;rd Birthday!&quot;</span></span><br><span class="line">TypeError: Can<span class="string">&#x27;t convert &#x27;</span><span class="built_in">int</span><span class="string">&#x27; object to str implicitly</span></span><br></pre></td></tr></table></figure><p>这是一个类型错误，意味着Python无法识别你使用的信息。在这个示例中，Python发现你使 用了一个值为整数(int)的变量，但它不知道该如何解读这个值(见)。Python知道，这个变 量表示的可能是数值23，也可能是字符2和3。像上面这样在字符串中使用整数时，需要显式地指 出你希望Python将这个整数用作字符串。为此，可调用函数str()，它让Python将非字符串值表示 为字符串:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">23</span></span><br><span class="line">message = <span class="string">&quot;Happy &quot;</span> + <span class="built_in">str</span>(age) + <span class="string">&quot;rd Birthday!&quot;</span></span><br><span class="line">print(message)</span><br></pre></td></tr></table></figure><p>这样，Python就知道你要将数值23转换为字符串，进而在生日祝福消息中显示字符2和3。经 过上述处理后，将显示你期望的消息，而不会引发错误:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Happy 23rd Birthday!</span><br></pre></td></tr></table></figure><p>大多数情况下，在Python中使用数字都非常简单。如果结果出乎意料，请检查Python是否按 你期望的方式将数字解读为了数值或字符串。</p><blockquote><p>小作业<br>6-1 编写 4 个表达式，它们分别使用加法、减法、乘法和除法运算，但结果都是数字 <code>8</code>。<br>为使用 print 语句来显示结果，务必将这些表达式用括号括起来，也就是说，你应该编写4行类似于下面的代码:<br><code>print(5 + 3)</code><br>输出应为 4 行，其中每行都只包含数字8。命名为<code>eight.py</code><br>6-2 将你最喜欢的数字存储在一个变量中，再使用这个变量创建一条消息，指出你最喜欢的数字，然后将这条消息打印出来。命名为<code>number.py</code></p></blockquote><p>想查看作业答案可以去<a href="https://github.com/Johnson8888/learn_python">我的Githu仓库</a></p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python 1-0】10个学习Python的理由以及Python的优势有哪些？</title>
      <link href="/reason-learn-python-1-0.html"/>
      <url>/reason-learn-python-1-0.html</url>
      
        <content type="html"><![CDATA[<h4 id="Python的由来"><a href="#Python的由来" class="headerlink" title="Python的由来"></a><strong>Python的由来</strong></h4><p>Python的创始人是<a href="https://baike.baidu.com/item/%E5%90%89%E5%A4%9A%C2%B7%E8%8C%83%E7%BD%97%E8%8B%8F%E5%A7%86">吉多·范罗苏姆</a>，1989年他在阿姆斯特丹的CWI工作，圣诞节期间，吉多·范罗苏姆为了打发圣诞节的无聊，决定开发一个新的脚本解释程序，作为ABC 语言的一种继承。之所以选择Python作为编程语言的名字，是因为他是BBC电视剧——蒙提·派森的飞行马戏团的爱好者。</p><h4 id="Python是什么"><a href="#Python是什么" class="headerlink" title="Python是什么"></a><strong>Python是什么</strong></h4><p>Python是一种被广泛使用的解释型、高级编程、通用型编程语言。Python支持多种编程范式，包括面向对象、结构化、指令式、函数式和反射式编程。它拥有动态类型系统和垃圾回收功能，能够自动管理内存使用，并且其本身拥有一个广泛的标准库。</p><h4 id="10个学习Python的理由"><a href="#10个学习Python的理由" class="headerlink" title="10个学习Python的理由"></a><strong>10个学习Python的理由</strong></h4><p>计算机语言已经出现很多年了，基本每隔10年就会出现一种新的编程语言，这多少让程序员们有些慌乱，不知道哪一种才是应该去学习和掌握的。<br>Python被认为是最受欢迎的编程语言之一。<br>在最近的<a href="https://stackoverflow.com/">Stack OverFlow</a>调查中，Python的热度已经超过了Java、C、C++，成为了第一。这也证明了Python是最受欢迎的语言之一。在这篇博客中，我将列出学习Python的10大理由。</p><h4 id="让我们拥抱Python吧"><a href="#让我们拥抱Python吧" class="headerlink" title="让我们拥抱Python吧"></a><strong>让我们拥抱Python吧</strong></h4><p>以下是列举的学习Python的10个理由：</p><ul><li>1.Python知名度高且容易拿到高薪</li><li>2.可应用于科研工作</li><li>3.脚本语言能够实现自动化</li><li>4.可应用于大数据</li><li>5.优秀的自动化测试功能</li><li>6.可开发桌面应用程序</li><li>7.可进行人工智能开发</li><li>8.支持Web服务开发</li><li>9.高可移植性和高可扩展性</li><li>10.上手简单学习容易</li></ul><p>Python语言正处于一个蓬勃发展的阶段，如果你考虑使用Python来解决一些问题，或者你想成为一名Python从业者，这正是学习和使用Python的好时机。<br>现在让我们来展开说一下这10个Python的优势：</p><h5 id="10-上手简单学习容易"><a href="#10-上手简单学习容易" class="headerlink" title="10.上手简单学习容易"></a><strong>10.上手简单学习容易</strong></h5><p>Python的语法跟自然语言很相似，使用起来非常简单。同时它又是非常强大的语言。<br>是什么使它如此简单呢，有以下几个特点：</p><ul><li>免费的 开源的</li><li>高级语言</li><li>解释型语言</li><li>有很多活跃的开发者社区</li></ul><p>在实际的编程过程中，Python的语法更简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 用 Java 输出 &quot;Hello World&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 用Python输出 &quot;Hello World&quot;</span></span><br><span class="line">print(<span class="string">&quot;Hello World&quot;</span>)</span><br></pre></td></tr></table></figure><p>使用<code>Java</code>语言输出<code>Hello World</code>，必须要写三行以上的代码，而使用<code>Python</code>语言一行就可以，如此简单的语法非常适合初学者。</p><h5 id="9-高可移植性和高可扩展性"><a href="#9-高可移植性和高可扩展性" class="headerlink" title="9.高可移植性和高可扩展性"></a><strong>9.高可移植性和高可扩展性</strong></h5><p>Python的可移植性体现在目前大多数平台都支持Python。它不仅能运行在Windows上，还可以运行在MacOS、Linux等平台上。<br>Python又被称为胶水语音，使用Python可以很方便的集成Java和.NET组件，同时也支持调用C和C++库。</p><h5 id="8-支持Web服务开发"><a href="#8-支持Web服务开发" class="headerlink" title="8.支持Web服务开发"></a><strong>8.支持Web服务开发</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_10_python_web_framework.jpg" alt="2020_10_10_python_web_framework"><br>Python有着一系列支持Web服务开发的框架，比较常见的框架有<a href="https://github.com/django/django">Django</a>、<a href="https://github.com/pallets/flask">Flask</a>、<a href="https://pylonsproject.org/">Pylons</a>等。这些框架都是用Python语言来实现的。<br>你可能也听说过用Python写爬虫来抓取数据，Python确实有着很多优秀的爬虫框架，比如<a href="https://scrapy.org/">Scrapy</a>、<a href="https://github.com/binux/pyspider">PySpider</a>、<a href="http://project.crawley-cloud.com/">Crawley</a>等等。</p><h5 id="7-可进行人工智能开发"><a href="#7-可进行人工智能开发" class="headerlink" title="7.可进行人工智能开发"></a><strong>7.可进行人工智能开发</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_10_python_artificial_intelligence.png" alt="2020_10_10_python_artificial_intelligence.png"><br>人工智能很可能就是下一次技术革命，Python同样可以用来开发人工智能，使用Python我们可以很简单的让机器模拟人的大脑，使机器具有思考、分析和决策的能力。<br>像 <a href="https://keras.io/">Keras</a>、<a href="https://www.tensorflow.org/">Tensorflow</a>、<a href="https://pytorch.org/">Pytorch</a>这些优秀的框架，本身就支持Python，我们只需要简单几行代码就可以体验到机器学习的乐趣。<br>在计算机视觉和图像识别上也有 <a href="https://github.com/opencv/opencv">OpenCV</a>这样优秀的框架，OpenCV也提供了大量的Python API。</p><h5 id="6-可开发桌面应用程序"><a href="#6-可开发桌面应用程序" class="headerlink" title="6.可开发桌面应用程序"></a><strong>6.可开发桌面应用程序</strong></h5><p><img src="https://raw.githubusercontent.com/Johnson8888/blog_pages/master/images/2020_10_10_python_desktop_app_development.png" alt="2020_10_10_python_desktop_app_development"><br>不管是在大型、小型、离线、在线项目中都能看到Python的影子，使用Python可以很快的构建GUI程序和桌面程序。常见的框架有<a href="https://docs.python.org/3/library/tkinter.html">Tkinter</a>。<br>同样Python也可以应用于游戏开发，<a href="https://www.pygame.org/news">Pygame</a> 是Python开发的一个很优秀的游戏框架，它同样支持运行在Android设备上。</p><h5 id="5-优秀的自动化测试功能"><a href="#5-优秀的自动化测试功能" class="headerlink" title="5.优秀的自动化测试功能"></a><strong>5.优秀的自动化测试功能</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_10_python_testing.png" alt="2020_10_10_python_testing"><br>Python有许多内置的测试框架，涵盖了测试、调试、打包、发布等工作流。使用这些框架可以简化我们的日常工作流程，使测试工作更简单更准确。常见的框架有<a href="www.selenium.dev">Selenium</a> 和<a href="https://pypi.org/project/splinter/">Splinter</a> 。<br>像<a href="https://docs.pytest.org/en/stable/">PyTest</a> 和<a href="https://robotframework.org/">Robot Framework</a> 是常见的Python测试框架，这些框架都支持跨平台和跨浏览器的测试。<br>测试是一项繁琐的任务，Python可以帮我们做的更好，所以，每个测试人员都应该掌握一些Python技术！</p><h5 id="4-可应用于大数据"><a href="#4-可应用于大数据" class="headerlink" title="4.可应用于大数据"></a><strong>4.可应用于大数据</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_10_python_big_data.png" alt="2020_10_10_python_big_data"><br>Python是处理大数据的利器，它支持并行计算，我们也可以在 大数据框架<a href="https://hadoop.apache.org/">Hadoop</a> 中使用Python，只需要引入<a href="https://pypi.org/project/pydoop/">Pydoop</a>就可以了，是不是很简单呢！<br>还有<a href="https://dask.org/">Dask</a> 和<a href="https://pypi.org/project/pyspark/">Pyspark</a> 可用于大数据处理。所以说在大数据领域Python也有着广泛的应用，使用Python可以帮助我们轻松的应对大数据！</p><h5 id="3-脚本语言能够实现自动化"><a href="#3-脚本语言能够实现自动化" class="headerlink" title="3.脚本语言能够实现自动化"></a><strong>3.脚本语言能够实现自动化</strong></h5><p>Python不仅是一门编程语言，它也可以作为脚本语言来使用。我们将代码以脚本的形式编写并执行，机器读取返回结果并处理，在脚本执行过程中我们可以发现一些执行错误并作出调整。一旦执行成功，后面我们就可以多次重复执行此脚本，这样的自动化脚本可以帮助我们节省很多工作时间。比如Python脚本可以帮助我们解压缩100个压缩文件，可以帮助我们把大量的汉字转成拼音等等。任何繁琐的重复的机械的工作都可以用Python脚本来完成。</p><h5 id="2-Python可应用于科研数据"><a href="#2-Python可应用于科研数据" class="headerlink" title="2.Python可应用于科研数据"></a><strong>2.Python可应用于科研数据</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_10_data_science.png" alt="2020_10_10_data_science"><br>在科研领域同样有很多科学家使用Python。多年来，很多科研人员都在使用<a href="https://www.mathworks.com/products/matlab.html">MATLAB</a> 进行科学研究，随着Python的数字引擎(如<a href="https://numpy.org/">Numpy</a> 和 <a href="https://pandas.pydata.org/">Pandas</a>) 的发布，在科研领域也有很多人开始使用Python。<br>Python还可以处理大量数据表格、矩阵计算以及数据统计，也可以使用”<a href="https://matplotlib.org/">Matplotlib</a>“和”<a href="http://seaborn.pydata.org/">Seaborn</a>“等流行库来将数据和计算可视化。</p><h5 id="1-Python知名度高且容易拿到高薪"><a href="#1-Python知名度高且容易拿到高薪" class="headerlink" title="1.Python知名度高且容易拿到高薪"></a><strong>1.Python知名度高且容易拿到高薪</strong></h5><p>我们随便在招聘平台搜索一下北京的招聘信息，可以看到薪水还是很不错的。<br><img src="https://raw.githubusercontent.com/Johnson8888/blog_pages/master/images/2020_10_10_python_salary.png" alt="2020_10_10_python_salary"></p><p>这是<a href="https://baike.baidu.com/item/TIOBE">Tiobe</a>2020年发布的计算机语言排名。Python排在第三名。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_10_python_top.png" alt="2020_10_10_python_top"><br>下面是近10年来计算机语音的趋势图<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_10_year_laguage.png" alt="2020_10_10_year_laguage"><br>不难看出，在过去的几年中，Python的受欢迎程度增速迅猛。<br>最后，我希望我的博客“学习Python的十大理由”对您有帮助。</p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jauns-gateway 报错【No package &#39;libssl&#39; found No package &#39;libcrypto&#39; found】</title>
      <link href="tips-janus-openssl-1.html"/>
      <url>tips-janus-openssl-1.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>No package ‘libssl’ found<br>No package ‘libcrypto’ found</p></blockquote><a id="more"></a><p><a href="http://fulade.me/tips-janus-openssl-1.html">文章首发地址</a></p><p>在Mac下配置janus-gateway服务器的时候遇到了找不到<code>libssl</code>和<code>libcrypto</code>错误，<br>详情如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure</span><br><span class="line">...</span><br><span class="line">checking for</span><br><span class="line">                    glib-2.0 &gt;&#x3D; 2.34</span><br><span class="line">libconfig</span><br><span class="line">                    nice</span><br><span class="line">                    jansson &gt;&#x3D; 2.5</span><br><span class="line">                    libssl &gt;&#x3D; 1.0.1</span><br><span class="line">                    libcrypto</span><br><span class="line">                    zlib</span><br><span class="line">                  ... no</span><br><span class="line">configure: error: Package requirements (</span><br><span class="line">                    glib-2.0 &gt;&#x3D; 2.34</span><br><span class="line">libconfig</span><br><span class="line">                    nice</span><br><span class="line">                    jansson &gt;&#x3D; 2.5</span><br><span class="line">                    libssl &gt;&#x3D; 1.0.1</span><br><span class="line">                    libcrypto</span><br><span class="line">                    zlib</span><br><span class="line">                  ) were not met:</span><br><span class="line"></span><br><span class="line">No package &#39;libssl&#39; found</span><br><span class="line">No package &#39;libcrypto&#39; found</span><br><span class="line"></span><br><span class="line">Consider adjusting the PKG_CONFIG_PATH environment variable if you</span><br><span class="line">installed software in a non-standard prefix</span><br></pre></td></tr></table></figure><p>只需要自定义<code>PKG_CONFIG_PATH</code>即可<br>在执行  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;janus PKG_CONFIG_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;openssl&#x2F;lib&#x2F;pkgconfig</span><br></pre></td></tr></table></figure><p>之前在命令行内执行一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PKG_CONFIG_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;openssl&#x2F;lib&#x2F;pkgconfig:&#x2F;usr&#x2F;local&#x2F;opt&#x2F;libffi&#x2F;lib&#x2F;pkgconfig</span><br></pre></td></tr></table></figure><p>如果没有安装<code>libffi</code>,可以使用 <code>Home brew</code>安装一下就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python 1-5】Python教程之——字符串</title>
      <link href="python-string-1-5.html"/>
      <url>python-string-1-5.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>字符串或串(String)是由数字、字母、下划线组成的一串字符。   </p></blockquote><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><strong>字符串</strong></h4><p>字符串就是一系列字符。在Python中，用引号括起的都是字符串，其中的引号可以是单引号， 也可以是双引号，如下所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;This is a string.&quot;</span>   </span><br><span class="line"><span class="string">&#x27;This is also a string.&#x27;</span></span><br></pre></td></tr></table></figure><p>这种灵活性让你能够在字符串中包含引号和撇号:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;I told my friend, &quot;Python is my favorite language!&quot;&#x27;</span></span><br><span class="line"><span class="string">&quot;The language &#x27;Python&#x27; is named after Monty Python, not the snake.&quot;</span> </span><br><span class="line"><span class="string">&quot;One of Python&#x27;s strengths is its diverse and supportive community.&quot;</span></span><br></pre></td></tr></table></figure><a id="more"></a><p><a href="http://fulade.me/python-string-1-5.html">文章首发地址</a></p><h4 id="使用方法修改字符串的大小写"><a href="#使用方法修改字符串的大小写" class="headerlink" title="使用方法修改字符串的大小写"></a><strong>使用方法修改字符串的大小写</strong></h4><p>对于字符串，可执行的最简单的操作之一是修改其中的单词的大小写。<br>请看下面的代码，并尝试判断其作用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;fulade blog&quot;</span> </span><br><span class="line">print(name.title())</span><br><span class="line">```  </span><br><span class="line">将这个文件保存为`name.py`，再运行它。你将看到如下输出:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Fulade Blog</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在这个示例中，小写的字符串&quot;fulade blog&quot;存储到了变量name中。在&#96;print()&#96;语句中，方法 &#96;title()&#96;出现在这个变量的后面。在&#96;name.title()&#96;中，name后 面的句点(.)让Python对变量name执行方法&#96;title()&#96;的操作。每个方法后面都跟着一对括号， 这是因为方法通常需要一些参数来完成其工作。这些参数往往写在括号内的。方法&#96;title()&#96;不需要参数，因此它后面的括号是空的。</span><br><span class="line">&#96;title()&#96;的实现结果是以首字母大写的方式显示每个单词，即将每个单词的首字母都改为大写。</span><br><span class="line">还有几个其他的很有用的处理大小写的方法。例如，要将符串改为全部大写或全部小写，可以像下面这样做:</span><br><span class="line">&#96;&#96;&#96; Python</span><br><span class="line">name &#x3D; &quot;Fulade Blog&quot;  </span><br><span class="line">print(name.upper()) </span><br><span class="line">print(name.lower())</span><br></pre></td></tr></table></figure><p>输出如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FULADE BLOG</span><br><span class="line">fulade blog</span><br></pre></td></tr></table></figure><h4 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a><strong>拼接字符串</strong></h4><p>在很多情况下，我们需要合并字符串。例如，你可能想将姓和名存储在不同的变量中，等要显示姓名时再将它们合而为一:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">first_name = <span class="string">&quot;Fu&quot;</span></span><br><span class="line">last_name = <span class="string">&quot;lade&quot;</span></span><br><span class="line">full_name = first_name + <span class="string">&quot; &quot;</span> + last_name</span><br><span class="line">print(full_name)</span><br></pre></td></tr></table></figure><p>Python使用加号(+)来合并字符串。在这个示例中，我们使用<code>+</code>来合并first_name、空格和<br>last_name，以得到完整的姓名，其结果如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fu lade</span><br></pre></td></tr></table></figure><p>这种合并字符串的方法称为拼接。通过拼接，可使用存储在变量中的字符串来创建完整的字符串。下面来看另外一个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">first_name = <span class="string">&quot;fu&quot;</span></span><br><span class="line">last_name = <span class="string">&quot;lade&quot;</span></span><br><span class="line">full_name = first_name + <span class="string">&quot; &quot;</span> + last_name</span><br><span class="line">message = <span class="string">&quot;Hello, &quot;</span> + full_name.title() + <span class="string">&quot;!&quot;</span></span><br><span class="line">print(message)</span><br></pre></td></tr></table></figure><p>上述代码显示消息”Hello, Fu Lade!”，但将这条消息存储在了一个变量中， 这让最后的<code>print</code>语句简单得多。</p><h4 id="使用制表符-按Tab键产生空格的叫做制表符-或换行符来添加空白"><a href="#使用制表符-按Tab键产生空格的叫做制表符-或换行符来添加空白" class="headerlink" title="使用制表符(按Tab键产生空格的叫做制表符)或换行符来添加空白"></a><strong>使用制表符(按Tab键产生空格的叫做制表符)或换行符来添加空白</strong></h4><p>在编程中，空白泛指任何非打印字符，如空格、制表符和换行符。你可使用空白来组织输出，使输出更易读。<br>要在字符串中添加制表符，可使用字符组合<code>\t</code>，如下代码所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;Python&quot;</span>)</span><br><span class="line">Python</span><br><span class="line">print(<span class="string">&quot;\tPython&quot;</span>)</span><br><span class="line">    Python</span><br></pre></td></tr></table></figure><p>要在字符串中添加换行符，可使用字符组合<code>\n</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;Languages:\nPython\nC\nJavaScript&quot;</span>) </span><br><span class="line">Languages:</span><br><span class="line">Python</span><br><span class="line">C</span><br><span class="line">JavaScript</span><br></pre></td></tr></table></figure><p>还可在同一个字符串中同时包含制表符和换行符。字符串”\n\t”让Python换到下一行，并在<br>  下一行开头添加一个制表符。下面的示例演示了如何使用一个单行字符串来生成四行输出:<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;Languages:\n\tPython\n\tC\n\tJavaScript&quot;</span>) </span><br><span class="line">Languages:</span><br><span class="line">    Python</span><br><span class="line">    C </span><br><span class="line">    JavaScript</span><br></pre></td></tr></table></figure></p><h4 id="删除空白和空格"><a href="#删除空白和空格" class="headerlink" title="删除空白和空格"></a><strong>删除空白和空格</strong></h4><p>在程序中，多余的空白可能令人迷惑。对程序员来说，<code>&#39;python&#39;</code>和<code>&#39;python &#39;</code>看起来几乎没什么两样，但对编译器来说，它们却是两个不同的字符串。Python能够发现’python ‘中多余的空格，并认为它是有意义的——除非你告诉它不是这样的。<br>空格很重要，因为你经常需要比较两个字符串是否相同。例如，在用户登陆网站的时候，我们需要对比用户名。但在有些场景下我们并不想要空格。所以，Python提供了很简单的删除空格的方法。<br>Python能够找出字符串开头和末尾多余的空白。要确保字符串末尾没有空白，可使用方法 <code>rstrip()</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">favorite_language = <span class="string">&quot;&#x27;python &#x27;&quot;</span> </span><br><span class="line">print(favorite_language)</span><br><span class="line"><span class="string">&#x27;python &#x27;</span></span><br><span class="line">print(favorite_language.rstrip())</span><br><span class="line"><span class="string">&#x27;python&#x27;</span></span><br><span class="line">print(favorite_language)</span><br><span class="line"><span class="string">&#x27;python &#x27;</span> </span><br></pre></td></tr></table></figure><p>存储在变量<code>favorite_language</code>中的字符串末尾包含多余的空格。你在运行这个代码的时候，可看到末尾的空格。对变量<code>favorite_language</code>调用方法 <code>rstrip()</code>后，这个多余的空格被删除了。然而，这种删除只是暂时的，接下来再次输出<code>favorite_language</code>的值时，你会发现这个字符串与输入时一样，依然包含多余的空格。<br>要永久删除这个字符串中的空格，必须将删除操作的结果保存回到变量中:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">favorite_language = <span class="string">&quot;&#x27;python &#x27;&quot;</span></span><br><span class="line">favorite_language = favorite_language.rstrip()</span><br><span class="line">print(favorite_language)</span><br><span class="line"><span class="string">&#x27;python&#x27;</span></span><br></pre></td></tr></table></figure><p>为删除这个字符串中的空格，你需要将其末尾的空格剔除，再将结果存回到原来的变量中。<br>在我们的日常开发中，经常需要修改变量的值，再将新值存回到原来的变量中。<br>你还可以剔除字符串开头的空格，或同时剔除字符串两端的空格。为此，可分别使用方法 <code>lstrip()</code>和<code>strip()</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">favorite_language = <span class="string">&quot;&#x27; python &#x27;&quot;</span> </span><br><span class="line">print(favorite_language.rstrip())</span><br><span class="line"><span class="string">&#x27; python&#x27;</span></span><br><span class="line">print(favorite_language.lstrip())</span><br><span class="line"><span class="string">&#x27;python &#x27;</span></span><br><span class="line">print(favorite_language.strip())</span><br><span class="line"><span class="string">&#x27;python&#x27;</span></span><br></pre></td></tr></table></figure><p>在这个示例中，我们首先创建了一个开头和末尾都有空格的字符串。接下来，我们 分别删除末尾、开头两端的空格。在实际程序开发中，这些剔除函数最常用于在存储用户输入前对输入进行清理。</p><h4 id="使用字符串时避免语法错误"><a href="#使用字符串时避免语法错误" class="headerlink" title="使用字符串时避免语法错误"></a><strong>使用字符串时避免语法错误</strong></h4><p>语法错误是一种经常会出现的错误。程序中包含非法的Python代码时，就会导致语法错误。 例如，在用单引号括起的字符串中，如果包含撇号，就将导致错误。这是因为这会导致Python将 第一个单引号和撇号之间的内容视为一个字符串，进而将余下的文本视为Python代码，从而引发 错误。<br>下面演示了如何正确地使用单引号和双引号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="string">&quot;One of Python&#x27;s strengths is its diverse community.&quot;</span> </span><br><span class="line">print(message)</span><br></pre></td></tr></table></figure><p>撇号位于两个双引号之间，因此Python解释器能够正确地理解这个字符串:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">One of Python<span class="string">&#x27;s strengths is its diverse community.</span></span><br></pre></td></tr></table></figure><p>然而，如果你使用单引号，Python将无法正确地确定字符串的结束位置:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="string">&#x27;One of Python&#x27;</span>s strengths <span class="keyword">is</span> its diverse community.<span class="string">&#x27;</span></span><br><span class="line"><span class="string">print(message)</span></span><br></pre></td></tr></table></figure><p>而你将看到如下输出:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="string">&#x27;One of Python&#x27;</span>s strengths <span class="keyword">is</span> its diverse community.<span class="string">&#x27;</span></span><br><span class="line"><span class="string">SyntaxError: invalid syntax</span></span><br></pre></td></tr></table></figure><p>从上面的输出我们可以看到，错误发生在第二个单引号后面。这种语法错误表明，在解释器看来，其中的有些内容不是有效的Python代码。错误的来源多种多样，这里指出一些常见的。学习 编写Python代码时，你可能会经常遇到语法错误。</p><p>所以，大家在做练习的时候也要细心，避免出现这种小错误。</p><blockquote><p>小作业<br>在做下面的每个练习时，都编写一个独立的程序，并将其保存为名称类似于 <code>name_cases.py</code> 的文件。<br>2-1 个性化消息:将用户的姓名存到一个变量中，并向该用户显示一条消息。显示 的消息应非常简单，如“Hello Eric, would you like to learn some Python today?”。<br>2-2 调整名字的大小写:将一个人名存储到一个变量中，再以小写、大写和首字母 大写的方式显示这个人名。<br>2-3 名言:找一句你钦佩的名人说的名言，将这个名人的姓名和他的名言打印出来。输出应类似于下面这样(包括引号):<br>Albert Einstein once said, “A person who never made a mistake never tried anything new.”<br>2-4 名言 【重复练习 2-3】，但将名人的姓名存储在变量 famous_person 中，再创建 要显示的消息，并将其存储在变量 message 中，然后打印这条消息。<br>2-5 剔除人名中的空白:存储一个人名，并在其开头和末尾都包含一些空白字符。 务必至少使用字符组合”\t”和”\n”各一次。<br>打印这个人名，以显示其开头和末尾的空白。然后，分别使用剔除函数 lstrip()、 rstrip()和 strip()对人名进行处理，并将结果打印出来。</p></blockquote><p>想查看作业答案可以去<a href="https://github.com/Johnson8888/learn_python">我的Githu仓库</a></p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python 1-4】Python教程之——变量</title>
      <link href="python-variable-1-4.html"/>
      <url>python-variable-1-4.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>变量来源于《数学》<br>是计算机语言中能储存计算结果或能表示值的抽象概念。<br><a href="http://fulade.me/python-variable-1-4.html">文章首发地址</a></p></blockquote><h5 id="运行hello-world-py时发生了什么"><a href="#运行hello-world-py时发生了什么" class="headerlink" title="运行hello_world.py时发生了什么"></a><strong>运行hello_world.py时发生了什么</strong></h5><p>运行hello_world.py时，Python都做了些什么呢?下面来深入研究一下。实际上，即便是运行简单的程序，Python所做的工作也相当多:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;Hello Python World!&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行上述代码代码时，你将看到如下输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello Python World!</span><br></pre></td></tr></table></figure><a id="more"></a><p>运行文件hello_world.py时，末尾的.py指出这是一个Python程序，因此编辑器将使用Python解释器来运行它。<br>Python解释器读取整个程序，确定其中每个单词的含义。例如，看到单词<code>print</code>时，解释器就会将括号中的内容打印到屏幕，而不会管括号中的内容是什么。<br>编写程序时，编辑器会以各种方式突出程序的不同部分。例如，它知道print是一个函数的名称，因此将其显示为蓝色；它知道”Hello Python world!”不是Python代码，因此将其显示为另一种颜色。这种功能称为<code>语法突出</code>。</p><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h5><p>下面来尝试在hello_world.py中使用一个变量。在这个文件开头添加一行代码，并对代码进行修改，修改如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="string">&quot;Hello Python world!&quot;</span> </span><br><span class="line">print(message) </span><br></pre></td></tr></table></figure><p>运行这个程序，看看结果如何。你会发现，输出跟前面一样：<br><code>Hello Python world! </code><br>我们添加了一个名为<code>message</code>的变量。每个变量都存储了一个值——与变量相关联的信息。<br>在这里，存储的值为文本”Hello Python world!”。<br>添加变量导致Python解释器需要做更多工作。处理第1行代码时，它将文本”Hello Python world!”与变量<code>message</code>关联起来；而处理第2行代码时，它将与变量<code>message</code>关联的值打印到屏幕。</p><p>下面来进一步扩展这个程序：修改hello_world.py，使其再打印一条消息。为此，在<br><code>hello_world.py</code>中添加一个空行，再添加下面两行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="string">&quot;Hello Python world!&quot;</span> </span><br><span class="line">print(message)</span><br><span class="line">message = <span class="string">&quot;Hello Python Crash Course world!&quot;</span> </span><br><span class="line">print(message) </span><br></pre></td></tr></table></figure><p>现在如果运行这个程序，将看到两行输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello Python world! </span><br><span class="line">Hello Python Crash Course world! </span><br></pre></td></tr></table></figure><p>在程序中可随时修改变量的值，而Python将始终记录变量的最新值。</p><h5 id="变量的命名"><a href="#变量的命名" class="headerlink" title="变量的命名"></a><strong>变量的命名</strong></h5><p>我们在命名变量的是应该遵循一定的规则，不能想怎么写就怎么写，简单来说有以下几个规则：</p><ul><li><p>变量名只能包含字母、数字和下划线。变量名可以字母或下划线打头，但不能以数字打<br>头，例如，可将变量命名为message_1，但不能将其命名为1_message。 </p></li><li><p>变量名不能包含空格，但可使用下划线来分隔其中的单词。例如，变量名greeting_message<br>可行，但变量名greeting message会引发错误。</p></li><li><p>不要将Python关键字和函数名用作变量名，即不要使用Python保留用于特殊用途的单词，如<code>print</code>。</p></li><li><p>变量名应既简短又具有描述性。例如，name比n好，student_name比s_n好，name_length<br>比length_of_persons_name好。</p></li><li><p>慎用小写字母l和大写字母O，因为它们可能被人错看成数字1和0。    </p></li></ul><p>要创建良好的变量名，需要经过一定的实践，在程序复杂而有趣时尤其如此。随着我们写的代码越来越多，并开始阅读别人编写的代码，将越来越善于创建有意义的变量名。</p><blockquote><p>小作业<br>请完成下面的练习，在做每个练习时，都编写一个独立的程序。保存每个程序时，使用符合标准 Python 约定的文件名：使用小写字母和下划线，如 simple_message.py 和simple_messages.py。<br>1-1 简单消息：将一条消息存储到变量中，再将其打印出来。<br>1-2 多条简单消息：将一条消息存储到变量中，将其打印出来；再将变量的值修改<br>为一条新消息，并将其打印出来。</p></blockquote><p>想查看作业答案可以去<a href="https://github.com/Johnson8888/learn_python">我的Githu仓库</a></p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一台电脑2个或多个Git账号如何配置和管理</title>
      <link href="git-multiple-user.html"/>
      <url>git-multiple-user.html</url>
      
        <content type="html"><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a><strong>引言</strong></h4><p>由于我在公司的Git源码服务器有一套账号和密码，我个人的Github又有一套账号和密码，这两个账号都需要PUSH和PULL代码，如果对Git使用的不太熟练，经常会遇到<code>git@github.com: Permission denied (publickey)</code>这种错误，那么我们该如何同时管理多个Git账号呢？</p><a id="more"></a><p>这里我们以MacOS系统为例。</p><h5 id="同一台电脑两个Git账号且账号相同"><a href="#同一台电脑两个Git账号且账号相同" class="headerlink" title="同一台电脑两个Git账号且账号相同"></a><strong>同一台电脑两个Git账号且账号相同</strong></h5><p>这里所说的账号相同，指的是：邮箱相同。比如我在公司Gitlab用的账号和Github的账号就是同一个邮箱，这种情况比较好处理，Gitlab和Github在校验的时候是只认邮箱的。只要我们把秘钥，也就是 <code>id_ras.pub</code>里面的内容在Gitlab和Github上都配置好就可以了。也就说多个Git源码服务器且都是使用同一个邮箱的情况下，我们只要把<code>id_ras.pub</code>配置到多个源码服务器就OK了！</p><h5 id="同一台电脑多个账号且账号不同"><a href="#同一台电脑多个账号且账号不同" class="headerlink" title="同一台电脑多个账号且账号不同"></a><strong>同一台电脑多个账号且账号不同</strong></h5><p>这个时候就需要我们指明哪个账号使用哪一个<code>.pub</code>文件了。我们需要在<code>~/.ssh</code>文件夹下创建名为<code>config</code>的文件，如果已经存在了该文件则需要修改一下。<br><code>config</code>的内容参考以下写法:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 第一个账号为 </span></span><br><span class="line"><span class="comment"># Email:fulade1@gmail.com  </span></span><br><span class="line"><span class="comment"># User:fulade1</span></span><br><span class="line"></span><br><span class="line">host gitlab.ttal.com</span><br><span class="line">    hostname gitlab.ttal.com</span><br><span class="line">    Port 65095</span><br><span class="line">    User fulade1</span><br><span class="line">    IdentityFile /home/Fulade/.ssh/id_rsa</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二个账号为 </span></span><br><span class="line"><span class="comment"># Email:fulade2@gmail.com  </span></span><br><span class="line"><span class="comment"># User:fulade2</span></span><br><span class="line"></span><br><span class="line">host gitlab-test.ttal.com</span><br><span class="line">    hostname gitlab.ttal.com</span><br><span class="line">    Port 65095</span><br><span class="line">    User fulade2</span><br><span class="line">    IdentityFile /home/Fulade/.ssh/id_rsa_second</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三个账号 </span></span><br><span class="line"><span class="comment"># Email:fulade2@gmail.com  </span></span><br><span class="line"><span class="comment"># User:fulade2</span></span><br><span class="line"></span><br><span class="line">host github.com</span><br><span class="line">    hostname github.com</span><br><span class="line">    Port 22</span><br><span class="line">    User fulade2</span><br><span class="line">    IdentityFile /home/Fulade/.ssh/id_rsa_second</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其中第二个账号跟第三个账号相同，只是源码服务器不同。</span></span><br></pre></td></tr></table></figure><p>因为配置了多个邮箱账号，所有git的global配置就要删除了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取消全局配置</span></span><br><span class="line">git config --global --<span class="built_in">unset</span> user.name</span><br><span class="line">git config --global --<span class="built_in">unset</span> user.email</span><br></pre></td></tr></table></figure><p>然后在每个Repo下配置账号就可以了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每个项目Repo设置自己的user.email</span></span><br><span class="line">git config  user.email <span class="string">&quot;xxxx@xx.com&quot;</span></span><br><span class="line">git config  user.name <span class="string">&quot;fulade&quot;</span></span><br></pre></td></tr></table></figure><p>这样就可以了。</p><h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a><strong>补充</strong></h5><p>指定<code>.pub</code>文件路径的方法：<br>需要使用命令<code>ssh-keygen -t rsa -C &quot;fulade@gmail.com&quot;</code>，接下来输入路径就可以了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;fulade@gmail.com&quot;</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/Users/Fulade/.ssh/id_rsa):/Users/Fulade/.ssh/id_rsa_second</span><br></pre></td></tr></table></figure><p>其中<code>/Users/Fulade/.ssh/id_rsa_second</code>是要输入的部分。<br>Have Fun !</p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【置顶】博客阅读指北</title>
      <link href="/top_index.html"/>
      <url>/top_index.html</url>
      
        <content type="html"><![CDATA[<h5 id="目前有两个系列-Flutter-和-Python稳定更新。"><a href="#目前有两个系列-Flutter-和-Python稳定更新。" class="headerlink" title="目前有两个系列 Flutter 和 Python稳定更新。"></a>目前有两个系列 <a href="http://fulade.me/categories/Flutter/">Flutter</a> 和 <a href="http://fulade.me/categories/Python/">Python</a>稳定更新。</h5><p>还有一些Tips不定时更新。</p><a id="more"></a><h3 id="Flutter系列"><a href="#Flutter系列" class="headerlink" title="Flutter系列"></a><strong>Flutter系列</strong></h3><p><a href="http://fulade.me/why-flutter-1-1.html">Flutter的8优势以及为什么要在下一个项目中尝试Flutter</a></p><h5 id="Flutter安装与运行"><a href="#Flutter安装与运行" class="headerlink" title="Flutter安装与运行"></a><strong>Flutter安装与运行</strong></h5><p><a href="http://fulade.me/windows-install-flutter.html">【Flutter1-1】在 Windows 10下配置Flutter开发环境</a><br><a href="http://fulade.me/not-support-vt-x.html">【Flutter1-2】在VMWare Android Studio 安装模拟器报错 Your CPU does not support VT-x</a><br><a href="http://fulade.me/windows-vscode-flutter-1-4.html">【Flutter1-3】Windows下VSCode配置Flutter开发环境</a><br><a href="http://fulade.me/flutter-hello-word-1-5.html">【Flutter1-4】运行Flutter的第一个项目——计数器</a><br><a href="http://fulade.me/flutter-project-files-1-6.html">【Flutter1-5】Flutter项目目录结构</a></p><h5 id="Dart语音基础"><a href="#Dart语音基础" class="headerlink" title="Dart语音基础"></a><strong>Dart语音基础</strong></h5><p><a href="">7. 待更新…</a></p><hr><h3 id="Python系列"><a href="#Python系列" class="headerlink" title="Python系列"></a><strong>Python系列</strong></h3><p><a href="http://fulade.me/reason-learn-python-1-0.html">【Python1-0】10个学习Python的理由以及Python的优势有哪些？</a></p><h5 id="Python安装与运行"><a href="#Python安装与运行" class="headerlink" title="Python安装与运行"></a><strong>Python安装与运行</strong></h5><p><a href="http://fulade.me/windows-install-python-1-1.html">【Python1-1】Windows 10 安装Python3环境</a><br><a href="http://fulade.me/vscode-install-python-1-2.html">【Python1-2】Visual Studio Code(VSCode) 配置 Python开发环境</a><br><a href="http://fulade.me/python-run-helloword-1-3.html">【Python1-3】Python的第一个程序 Hello World</a></p><h5 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a><strong>Python基础</strong></h5><p><a href="http://fulade.me/python-variable-1-4.html">【Python 1-4】Python教程之——变量</a><br><a href="http://fulade.me/python-string-1-5.html">【Python 1-5】Python教程之——字符串</a><br><a href="http://fulade.me/python-number-1-6.html">【Python 1-6】Python教程之——数字</a></p><hr><h4 id="其他系列"><a href="#其他系列" class="headerlink" title="其他系列"></a><strong>其他系列</strong></h4><p><a href="http://fulade.me/how-to-set-up-hexo-blog.html">1. Mac下使用GitHub+Hexo搭建个人博客</a></p><h4 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a><strong>补充说明</strong></h4><h5 id="目前只有两个系列-Flutter-和-Python"><a href="#目前只有两个系列-Flutter-和-Python" class="headerlink" title="目前只有两个系列 Flutter 和 Python"></a>目前只有两个系列 <a href="http://fulade.me/categories/Flutter/">Flutter</a> 和 <a href="http://fulade.me/categories/Python/">Python</a></h5><h5 id="如果大家有喜欢的教程尽管留言，我也会考虑更新。"><a href="#如果大家有喜欢的教程尽管留言，我也会考虑更新。" class="headerlink" title="如果大家有喜欢的教程尽管留言，我也会考虑更新。"></a>如果大家有喜欢的教程尽管留言，我也会考虑更新。</h5><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 说明 </tag>
            
            <tag> 置顶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 1-5】运行Flutter的第一个项目——计数器</title>
      <link href="/flutter-hello-word-1-5.html"/>
      <url>/flutter-hello-word-1-5.html</url>
      
        <content type="html"><![CDATA[<h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a><strong>创建项目</strong></h4><p>创建Flutter项目有很多种方法，各个IDE工具也都集成了创建Flutter项目的快捷操作。我们这里列举三种方式：使用命令行创建、使用Android Studio创建和使用VSCode创建。</p><a id="more"></a><blockquote><p>文末附有视频教程</p></blockquote><ul><li>使用命令行创建<br>在Flutter安装完之后，我们就已经配置好了命令行工具，命令行工具很强大，可以满足我们日常开发Flutter的所有操作（如果你还没有安装好Flutter环境，可以参考<a href="http://fulade.me/2020/09/28/windows-install-flutter/">这里</a>来安装）。<br>我们只需要打开命令行工具 输入:  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter create flutter_app</span><br></pre></td></tr></table></figure>  其中 <code>flutter_app</code>是我们项目的名字。</li><li>使用 Android Studio 创建<br>我们打开 Android Studio，点击左上角 <code>File</code>-&gt;<code>New</code>-&gt;<code>New Flutter Project</code> 即可。<br><img src="https://cdn.jsdelivr.net/gh/Johnson8888/blog_pages/images/2020_10_25_android_create.png" alt="2020_10_25_android_create"></li><li>使用 VSCode创建<br>点击VSCode上方按钮 <code>View</code>-&gt;<code>Command Palette..</code><br><img src="https://cdn.jsdelivr.net/gh/Johnson8888/blog_pages/images/2020_10_25_vscode_view.png" alt="2020_10_25_vscode_view.png"><br>然后在弹出的输入框内输入关键字<code>flutter</code>回车就可以了创建项目了。<br><img src="https://cdn.jsdelivr.net/gh/Johnson8888/blog_pages/images/2020_10_25_vscode_flutter.png" alt="2020_10_25_vscode_flutter"></li></ul><h4 id="使用Android-Studio-运行-计数器项目"><a href="#使用Android-Studio-运行-计数器项目" class="headerlink" title="使用Android Studio 运行 计数器项目"></a><strong>使用Android Studio 运行 计数器项目</strong></h4><p>用 Android Studio打开我们刚刚创建的项目<code>flutter_app</code><br>打开之后我们先选择一下模拟器，然后直接点击运行就可以了。<br><img src="https://cdn.jsdelivr.net/gh/Johnson8888/blog_pages/images/2020_10_25_android_select_device.png" alt="2020_10_25_android_select_device"></p><h4 id="使用VSCode-运行-计数器项目"><a href="#使用VSCode-运行-计数器项目" class="headerlink" title="使用VSCode 运行 计数器项目"></a><strong>使用VSCode 运行 计数器项目</strong></h4><p>用VSCode打开项目<code>flutter_app</code>，找到目录下的 <code>main.dart</code>文件打开<br><img src="https://cdn.jsdelivr.net/gh/Johnson8888/blog_pages/images/2020_10_25_vscode_main_dart.png" alt="2020_10_25_vscode_main_dart"><br>然后点击右上角运行按钮就可以了。<br><img src="https://cdn.jsdelivr.net/gh/Johnson8888/blog_pages/images/2020_10_25_vscode_run.png" alt="2020_10_25_vscode_run"></p><h5 id="视频教程"><a href="#视频教程" class="headerlink" title="视频教程"></a><strong>视频教程</strong></h5><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=245172764&bvid=BV1wv411r7Po&cid=251359013&page=1"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 1-6】Flutter项目目录结构</title>
      <link href="/flutter-project-files-1-6.html"/>
      <url>/flutter-project-files-1-6.html</url>
      
        <content type="html"><![CDATA[<h5 id="Flutter项目结构"><a href="#Flutter项目结构" class="headerlink" title="Flutter项目结构"></a><strong>Flutter项目结构</strong></h5><p>了解Flutter的目录结构，可以帮助我们更好的管理和开发项目。这样我们在开发的过程中就会很清楚的知道，iOS代码该放在那里，Android代码该放在那里，Flutter代码该放在哪里，测试代码放在哪里等等。</p><a id="more"></a><p>我们以<a href="http://fulade.me/2020/10/25/flutter-hello-word-1-5/">上一节</a>中创建的<code>flutter_app</code>为例，我们用VSCode打开它。<br><img src="https://cdn.jsdelivr.net/gh/Johnson8888/blog_pages/images/2020_10_25_vscode_main_dart.png" alt="2020_10_25_vscode_main_dart"><br>如图，我们看到了下面这些目录：  </p><table><thead><tr><th>文件或目录</th><th>说明</th></tr></thead><tbody><tr><td>.dart_tool</td><td>记录了一些dart工具库所在的位置和信息</td></tr><tr><td>.idea</td><td>android studio 是基于idea开发的，.idea 记录了项目的一些文件的变更记录</td></tr><tr><td>android</td><td>Android项目文件夹</td></tr><tr><td>ios</td><td>iOS项目文件夹</td></tr><tr><td>lib</td><td>lib文件夹内存放我们的dart语音代码</td></tr><tr><td>test</td><td>用于存放我们的测试代码</td></tr><tr><td>.gitignore</td><td>git忽略配置文件</td></tr><tr><td>.metadata</td><td>IDE 用来记录某个 Flutter 项目属性的的隐藏文件</td></tr><tr><td>.packages</td><td>pub 工具需要使用的，包含 package 依赖的 yaml 格式的文件</td></tr><tr><td>flutter_app.iml</td><td>工程文件的本地路径配置</td></tr><tr><td>pubspec.lock</td><td>当前项目依赖所生成的文件</td></tr><tr><td>pubspec.yaml</td><td>当前项目的一些配置文件，包括依赖的第三方库、图片资源文件等</td></tr><tr><td>README.md</td><td>READEME文件</td></tr></tbody></table><h5 id="比较重要的四个文件夹是-android、ios、lib、test"><a href="#比较重要的四个文件夹是-android、ios、lib、test" class="headerlink" title="比较重要的四个文件夹是 android、ios、lib、test"></a><strong>比较重要的四个文件夹是 android、ios、lib、test</strong></h5><ul><li>lib<br>我们日常开发的dart语言代码都放在这里，可以说是我们的“核心工作文件夹”</li><li>ios<br>这里面包含了iOS项目相关的配置和文件，当我们的项目需要打包上线的时候，需要打开该文件内的<code>Runner.xcworkspace</code>文件进行编译和打包工作。</li><li>android<br>与<code>ios</code>文件夹一样，在android项目需要打包上架的时候，也需要使用此文件夹里面的文件。同样的如果我们需要原生代码的支持，原生代码也是放在这里。</li><li>test<br>这里存放了我们在项目开发过程中的测试代码，良好的测试习惯是保证代码质量的必要手段，希望大家在<code>test</code>文件里写更多的代码！</li></ul><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python 1-2】Visual Studio Code(VSCode) 配置 Python开发环境</title>
      <link href="/vscode-install-python-1-2.html"/>
      <url>/vscode-install-python-1-2.html</url>
      
        <content type="html"><![CDATA[<h5 id="使用-VSCode-作为开发Python的IDE工具"><a href="#使用-VSCode-作为开发Python的IDE工具" class="headerlink" title="使用 VSCode 作为开发Python的IDE工具"></a><strong>使用 VSCode 作为开发Python的IDE工具</strong></h5><p>IDE(Integrated Development Environment, 集成开发环境)，目前支持Python的IDE有很多。有PyCharm、Eclipse、Atom、Anaconda、Sublime Text等等。我个人更喜欢使用 Visual Studio Code 也就是 VSCode。如果大家有自己喜欢的IDE工具，尽情享用！<br><a href="http://fulade.me/2020/10/20/vscode-install-python-1-2/">文章首发地址</a></p><h5 id="在-VSCode-里面安装Python扩展工具"><a href="#在-VSCode-里面安装Python扩展工具" class="headerlink" title="在 VSCode 里面安装Python扩展工具"></a><strong>在 VSCode 里面安装Python扩展工具</strong></h5><p>首先确保我们的机器上面已经安装好了<code>Python</code>环境，如果没有安装，<a href="http://fulade.me/2020/10/04/windows-install-python-1-1/">可参考我的另一篇教程来安装Python环境</a>，步骤很简单。<br>然后我们打开已经安装好的VSCode，找到 <code>Extensions</code>并点击(或使用快捷键<code>Ctrl+Shift+X</code>来打开)。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_17_vscode_extensions_tag.png" alt="2020_10_17_vscode_extensions_tag"><br>在弹出的输入框中 输入<code>Python</code>并搜索，出现的第一个结果我们直接点击<code>Install</code>就可以了。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_17_vscode_extensions_search.png" alt="2020_10_17_vscode_extensions_search"><br>等待Install结束后，也就安装好了。</p><h5 id="测试安装是否成功"><a href="#测试安装是否成功" class="headerlink" title="测试安装是否成功"></a><strong>测试安装是否成功</strong></h5><p>我们新建名为<code>hello_world.py</code>的文件，写入如下一行代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;hello world!&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后点击右上角的<code>绿色三角按钮</code>运行，看到有控制台输出<code>hello world!</code>就代表我们安装成功了！<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_17_vscode_run.png" alt="2020_10_17_vscode_run"></p><h5 id="视频教程"><a href="#视频教程" class="headerlink" title="视频教程"></a><strong>视频教程</strong></h5><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=712535982&bvid=BV1KD4y197PB&cid=247590406&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python 1-3】Python的第一个程序 Hello World</title>
      <link href="/python-run-helloword-1-3.html"/>
      <url>/python-run-helloword-1-3.html</url>
      
        <content type="html"><![CDATA[<h5 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a><strong>Hello World</strong></h5><p>“Hello, World!” 程序是一个经典的，确立已久的传统电脑程序。”Hello, World!” 因为能展示一个语言的基本句法，因此常被用作初学者的第一个”简单但完整”的程序，并可以被用来测试编程环境。</p><p>下面我们将写出Python中的”Hello, World!”程序，并使用两种方式运行它。</p><p><a href="http://fulade.me/2020/10/20/python-run-helloword-1-3/">文章首发地址</a></p><h5 id="书写-Hello-World程序"><a href="#书写-Hello-World程序" class="headerlink" title="书写 Hello World程序"></a><strong>书写 Hello World程序</strong></h5><p>首先我们打开VSCode，新建一个文件，想必大家也都知道了，<code>Python</code>的输出语句非常简单，我们只需要在新建的文件中写入如下一行代码就可以了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;hello world!&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后使用快捷键<code>Ctrl+S</code>保存文件到<code>桌面</code>，文件名我们就命名为<code>hello_world.py</code>这样我们的Hello World程序就写完了！是不是很简单！</p><h5 id="使用-VSCode运行-hello-world-py"><a href="#使用-VSCode运行-hello-world-py" class="headerlink" title="使用 VSCode运行 hello_world.py"></a><strong>使用 VSCode运行 hello_world.py</strong></h5><p>然后点击右上角的<code>绿色三角按钮</code>运行，看到有控制台输出<code>hello world!</code>，我们的程序运行成功了！<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_17_vscode_run.png" alt="2020_10_17_vscode_run"></p><h5 id="使用命令行运行-hello-world-py"><a href="#使用命令行运行-hello-world-py" class="headerlink" title="使用命令行运行 hello_world.py"></a><strong>使用命令行运行 hello_world.py</strong></h5><p>我们打开<code>Windows PowerShell</code>，输入<code>cd .\Desktop</code> 按回车，这样就进入到<code>hello_world.py</code>所在的文件夹，接着再输入<code>python.exe .\hello_world.py</code><br>看到有输出<code>hello world!</code>，我们用命令行工具也运行成功了！<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_17_command_run.png" alt="2020_10_17_command_run"></p><h5 id="两种运行方式的使用场景"><a href="#两种运行方式的使用场景" class="headerlink" title="两种运行方式的使用场景"></a><strong>两种运行方式的使用场景</strong></h5><p>其实在日常工作中，我个人就是使用VSCode来开发，所以也是使用VSCode来运行和调试Python程序的，这样简单也方便，直接使用快捷键运行一下就可以了。<br>但是当我们的Python程序需要部署在一台没有安装任何IDE工具的机器上的时候，这个时候我们就可以使用命令行来启动我们的Python程序来运行。<br>同样的，当其他脚本想启动我们的Python程序的时候，大多数情况也是通过命令行工具来运行的。</p><h5 id="视频教程"><a href="#视频教程" class="headerlink" title="视频教程"></a><strong>视频教程</strong></h5><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=800034187&bvid=BV1My4y187ov&cid=247600869&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 1-4】Windows下VSCode配置Flutter开发环境</title>
      <link href="/windows-vscode-flutter-1-4.html"/>
      <url>/windows-vscode-flutter-1-4.html</url>
      
        <content type="html"><![CDATA[<h5 id="VSCode是什么"><a href="#VSCode是什么" class="headerlink" title="VSCode是什么"></a><strong>VSCode是什么</strong></h5><p>Visual Studio Code（简称VS Code）是一个由微软开发，同时支持Windows 、 Linux和macOS等操作系统的免费代码编辑器，它支持测试，并内置了Git 版本控制功能，同时也具有开发环境功能，例如代码补全（类似于 IntelliSense）、代码片段和代码重构等。该编辑器支持用户个性化配置，例如改变主题颜色、键盘快捷方式等各种属性和参数，同时还在编辑器中内置了扩展程序管理的功能。VSCode同样支持Flutter开发，在我的日常开发中会更多的使用VSCode，而不是Android Studio。</p><a id="more"></a><h5 id="下载和安装VSCode"><a href="#下载和安装VSCode" class="headerlink" title="下载和安装VSCode"></a><strong>下载和安装VSCode</strong></h5><p>打开<a href="https://code.visualstudio.com/">VSCode官方网站</a><br><img src="https://cdn.jsdelivr.net/gh/Johnson8888/blog_pages/images/2020_10_09_download_vscode.png" alt="2020_10_09_download_vscode"><br>下在完成后双击<code>exe</code>文件进行安装并打开。<br>打开后找到<code>Extensions</code>或使用快捷键<code>Ctrl+Shift+X</code>打开扩展中心。<br>在扩展中心输入<code>flutter</code>，显示的第一个便是我们要安装的Flutter扩展程序，点击安装。<br><img src="https://cdn.jsdelivr.net/gh/Johnson8888/blog_pages/images/2020_10_09_vscode_flutter.png" alt="2020_10_09_vscode_flutter"></p><h5 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a><strong>新建项目</strong></h5><p>安装完成之后依次点击<code>View</code>-&gt;<code>Command Palette...</code>(或者是使用快捷键<code>Ctrl+Shift+P</code>)<br><img src="https://cdn.jsdelivr.net/gh/Johnson8888/blog_pages/images/2020_10_09_vscode_command.png" alt="2020_10_09_vscode_command"><br>在弹出的输入框中输入关键字<code>flutter</code>然后回车，选择项目要保持的目录，输入项目名称就可以了。<br><img src="https://cdn.jsdelivr.net/gh/Johnson8888/blog_pages/images/2020_10_09_vscode_new_flutter.png" alt="2020_10_09_vscode_new_flutter"><br>注意：创建项目完成之后，VSCode会帮助我们来安装<code>Dart</code>语言相关的依赖。<br>这样我们在VSCode下配置Flutter环境就算完成了。</p><h5 id="视频教程"><a href="#视频教程" class="headerlink" title="视频教程"></a>视频教程</h5><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=287403050&bvid=BV1gf4y1B7yJ&cid=245689967&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;">    </iframe></div>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 1-3】在VMWare Android Studio 安装模拟器报错 Your CPU does not support VT-x</title>
      <link href="/not-support-vt-x.html"/>
      <url>/not-support-vt-x.html</url>
      
        <content type="html"><![CDATA[<p><a href="http://fulade.me/2020/10/08/not-support-vt-x/">文章首发地址</a></p><h4 id="出现这个问题的原因"><a href="#出现这个问题的原因" class="headerlink" title="出现这个问题的原因"></a><strong>出现这个问题的原因</strong></h4><p>Android模拟器需要计算器的处理器必须支持以下虚拟化扩展技术之一：</p><ul><li>Intel 虚拟化技术（VT、VT-x 和 vmx）扩展</li><li>AMD 虚拟化（AMD-V 和 SVM）扩展</li></ul><p>大部分处理器都会支持，这里就以Intel处理器为例。</p><a id="more"></a><h4 id="在BOIS内开启"><a href="#在BOIS内开启" class="headerlink" title="在BOIS内开启"></a><strong>在BOIS内开启</strong></h4><p>如果之前没有开启过虚拟化，需要我们进入到BIOS开启，各个主板进入BIOS的方式不同，这里就不一一列举了。</p><h4 id="编辑VMWare-虚拟机配置"><a href="#编辑VMWare-虚拟机配置" class="headerlink" title="编辑VMWare 虚拟机配置"></a><strong>编辑VMWare 虚拟机配置</strong></h4><p>打开<code>VMware Workstation Pro</code>，找到要编辑的虚拟机，依次点击<code>编辑虚拟机</code>-&gt;<code>处理器</code>-&gt;<code>虚拟化 Intel VT-x/EPT 或 AMD V/RVI(V)</code><br><img src="https://raw.githubusercontent.com/Johnson8888/blog_pages/master/images/2020_10_08_vt-x.png" alt="2020_10_08_vt-x"><br>编辑后保持一下，重启虚拟机就可以了。</p><h4 id="HAXM-is-not-installed"><a href="#HAXM-is-not-installed" class="headerlink" title="HAXM is not installed"></a><strong>HAXM is not installed</strong></h4><p>接下来在安装模拟器的时候还有可能会遇到<code>HAXM is not installed</code>错误<br>这里就直接点击下面的 <code>Install Haxm</code>就可以了！</p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python 1-1】Windows 10 安装Python3环境</title>
      <link href="/windows-install-python-1-1.html"/>
      <url>/windows-install-python-1-1.html</url>
      
        <content type="html"><![CDATA[<p>[收看视频教程的拖到文章末尾查看]</p><h4 id="Windows-10-安装Python3环境"><a href="#Windows-10-安装Python3环境" class="headerlink" title="Windows 10 安装Python3环境"></a>Windows 10 安装Python3环境</h4><h5 id="1-首先打开Python-官网"><a href="#1-首先打开Python-官网" class="headerlink" title="1. 首先打开Python 官网"></a>1. 首先打开Python <a href="https://www.python.org/">官网</a></h5><h5 id="2-在官网的主页找到-Downloads选项并点击"><a href="#2-在官网的主页找到-Downloads选项并点击" class="headerlink" title="2. 在官网的主页找到 Downloads选项并点击"></a>2. 在官网的主页找到 <code>Downloads</code>选项并点击</h5><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/Inked2020_10_4_python_org_LI.jpg" alt="python_org"></p><a id="more"></a><h5 id="3-找到-Windows选项-并点击-Python3-8-5即可下载Python3安装包"><a href="#3-找到-Windows选项-并点击-Python3-8-5即可下载Python3安装包" class="headerlink" title="3. 找到 Windows选项 并点击 Python3.8.5即可下载Python3安装包"></a>3. 找到 <code>Windows</code>选项 并点击 <code>Python3.8.5</code>即可下载Python3安装包</h5><p>由于官方在不断更新和维护，所以这里不一定是恰好是<code>Python3.8.5</code>，选择自己想安装的版本即可<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/Inked2020_10_4_select_windows_LI.jpg" alt="windows"><br>然后等待安装文件下载完成</p><h5 id="4-开始安装"><a href="#4-开始安装" class="headerlink" title="4. 开始安装"></a>4. 开始安装</h5><p>双击我们下载好的<code>python-3.8.5-amd64.exe</code>文件<br>我们选择<code>Customize installation</code>并且勾选<code>Add Python 3.8 to PATH</code>，勾选这个选项的目的是将Python直接添加到环境变量中，便于使用。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_4_add_python.jpg" alt="custom_install"></p><h5 id="5-安装成功提示"><a href="#5-安装成功提示" class="headerlink" title="5.安装成功提示"></a>5.安装成功提示</h5><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_4_install_success.jpg" alt="install_success"></p><h5 id="6-命令行测试安装是否完整"><a href="#6-命令行测试安装是否完整" class="headerlink" title="6.命令行测试安装是否完整"></a>6.命令行测试安装是否完整</h5><p>我们打开Windows 10 自带的命令行工具<code>Windows PowerShell</code>，然后在命令行输入 <code>python -V</code>看到能够输出版本号，就意味这我们的Python安装成功了。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_4_cmd.jpg" alt="cmd"></p><h5 id="7-视频教程"><a href="#7-视频教程" class="headerlink" title="7. 视频教程"></a>7. 视频教程</h5><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=372253752&bvid=BV1JZ4y157u8&cid=243496843&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;">    </iframe></div>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 1-1】8个Flutter的优势以及为什么要在下一个项目中尝试Flutter</title>
      <link href="/why-flutter-1-1.html"/>
      <url>/why-flutter-1-1.html</url>
      
        <content type="html"><![CDATA[<p>让我们一起来了解Flutter与其他跨平台框架的优势，以及这些优势在开发流程中的作用。</p><ul><li><h4 id="Flutter是什么"><a href="#Flutter是什么" class="headerlink" title="Flutter是什么"></a><a href="#jump1">Flutter是什么</a></h4></li><li><h4 id="Flutter的优势"><a href="#Flutter的优势" class="headerlink" title="Flutter的优势"></a><a href="#jump2">Flutter的优势</a></h4><ul><li><h5 id="1-跨平台使用相同的UI和业务逻辑"><a href="#1-跨平台使用相同的UI和业务逻辑" class="headerlink" title="1. 跨平台使用相同的UI和业务逻辑"></a><a href="#jump2_1">1. 跨平台使用相同的UI和业务逻辑</a></h5></li><li><h5 id="2-节省开发时间"><a href="#2-节省开发时间" class="headerlink" title="2. 节省开发时间"></a><a href="#jump2_2">2. 节省开发时间</a></h5></li><li><h5 id="3-更快的迭代速度"><a href="#3-更快的迭代速度" class="headerlink" title="3. 更快的迭代速度"></a><a href="#jump2_3">3. 更快的迭代速度</a></h5></li><li><h5 id="4-无限接近原生的交互体验"><a href="#4-无限接近原生的交互体验" class="headerlink" title="4. 无限接近原生的交互体验"></a><a href="#jump2_4">4. 无限接近原生的交互体验</a></h5></li><li><h5 id="5-丰富的UI动画"><a href="#5-丰富的UI动画" class="headerlink" title="5. 丰富的UI动画"></a><a href="#jump2_5">5. 丰富的UI动画</a></h5></li><li><h5 id="6-独立的渲染引擎"><a href="#6-独立的渲染引擎" class="headerlink" title="6. 独立的渲染引擎"></a><a href="#jump2_6">6. 独立的渲染引擎</a></h5></li><li><h5 id="7-能够很容易与原生进行交互"><a href="#7-能够很容易与原生进行交互" class="headerlink" title="7. 能够很容易与原生进行交互"></a><a href="#jump2_7">7. 能够很容易与原生进行交互</a></h5></li><li><h5 id="8-不只是能运行在移动端"><a href="#8-不只是能运行在移动端" class="headerlink" title="8. 不只是能运行在移动端"></a><a href="#jump2_8">8. 不只是能运行在移动端</a></h5></li></ul></li><li><h4 id="从业务层来看，Flutter是一个好的选择吗？"><a href="#从业务层来看，Flutter是一个好的选择吗？" class="headerlink" title="从业务层来看，Flutter是一个好的选择吗？"></a><a href="#jump3">从业务层来看，Flutter是一个好的选择吗？</a></h4></li><li><h4 id="为什么要尝试使用Fultter"><a href="#为什么要尝试使用Fultter" class="headerlink" title="为什么要尝试使用Fultter?"></a><a href="#jump4">为什么要尝试使用Fultter?</a></h4></li></ul><h4 id="Flutter是什么-1"><a href="#Flutter是什么-1" class="headerlink" title="Flutter是什么"></a><span id="jump1">Flutter是什么</span></h4><p>就我目前的职业开发生涯中，目睹了太多太多项目不知道该选择哪种跨平台方案的例子。这些项目都是不同的，但是我们都希望这些项目能够运行在更多平台和更多设备上，常见的作法就是在不同的客户端招聘不同的开发人员来进行开发工作，比如手机端有iOS程序员和Android程序员等等。<br>我记得在2013年，我第一次看到了比较完善的跨平台游戏开发方案，那时候我就在想，为什么App端没有这种工具可以满足我们跨平台的需求呢？<br>但是，现在我们有了，它就是Flutter！我将在下面介绍我使用Flutter做了些什么，希望能对你有所帮助或启发。<br>我有过一些iOS开发经验，也有过一些游戏开发经验，可以说Flutter就是我一直在寻找的跨平台解决方案。它不仅使用简单，还能保持跨平台UI的一致性时，并且很容易的与原生进行交互。是非常好的体验。</p><a id="more"></a><h4 id="Flutter的优势-1"><a href="#Flutter的优势-1" class="headerlink" title="Flutter的优势"></a><span id="jump2">Flutter的优势</span></h4><p>你之前可能会了解到，所有的跨平台框架都会在节约开发时间上有所帮助。但是，Flutter在有些地方跟其他框架有很多不同，让我们来看看，究竟Flutter比其他跨平台框架在哪些地方做的更好。</p><h5 id="1-跨平台使用相同的UI和业务逻辑-1"><a href="#1-跨平台使用相同的UI和业务逻辑-1" class="headerlink" title="1. 跨平台使用相同的UI和业务逻辑"></a><span id="jump2_1">1. 跨平台使用相同的UI和业务逻辑</span></h5><p>我们知道，基本上所有的跨平台框架都提供了一种在目标平台之间共享代码的实现方式。但是没有任何一个平台像Flutter这样允许共享UI代码以及UI本身。<br>为了说明这一点，下面我们来看一下其中一个跨平台框架UI的实现逻辑：<br><img src="https://raw.githubusercontent.com/Johnson8888/blog_pages/master/images/2020_09_30_other_paltform.png" alt="2020_09_30_other_paltform"><br>React Navite 的渲染过程看起来像是在每个平台上都很简单。但是从图中我们不难发现，这种渲染过程需要依然各个平台原生组件来进行渲染，React Native 就是帮我们实现了对各个平台应用层UI控件的映射。这就需要将每个动画每个UI映射到各个平台的动画和UI上，显然这比较繁琐。<br>相比之下，Flutter不需要依赖热任何平台的UI组件就能生成UI界面。Flutter唯一需要的就是一个画布，也就是我们常说的Canvas。<br>下面是Flutter的渲染过程:<br><img src="https://raw.githubusercontent.com/Johnson8888/blog_pages/master/images/2020_09_30_flutter_canvas.png" alt="2020_09_30_flutter_canvas"><br>Flutter能够在任何平台上构建完全一模一样的的UI，这种独特的渲染方式是它脱颖而出的关键。<br>简而言之，使用Flutter来实现UI和业务逻辑能够节省时间和精力，并且同时不影响最终产品的性能。原来iOS、Android需要每个平台都要配备相应的程序员，使用Flutter只需要一组程序员就可以了，还节省了程序员！</p><h5 id="2-节省开发时间-1"><a href="#2-节省开发时间-1" class="headerlink" title="2. 节省开发时间"></a><span id="jump2_2">2. 节省开发时间</span></h5><p>依据我个人的开发经验，从编译到运行一个Android App至少需要40秒的时间。同时，在调试UI的过程中需要不停的编译和运行，这就需要消耗大量的时间。诚然，Android Studio是具有布局预览功能的，但是总有一点不足的是：Android Studio 不能每次都像预期那样运行，特别是在自定义View的时候。<br>Flutter的 “热重载”功能可以让我们实时看到应用的变化，并且不会丢失当前应用程序的状态。这就是使用Flutter节省开发时间的根本原因。<br>此外，Flutter团体还付出了很多努力来提供各种控件。这些控件大多数都可以自定义，这就在构建UI上给我们节省了不少时间。除了众多的核心控件外，Flutter还提供了大量的Material(Android风格)和Cupertino(iOS风格)的控件可以满足不同的设计风格。<br>如下图：<br><img src="https://raw.githubusercontent.com/Johnson8888/blog_pages/master/images/2020_09_30_services.png" alt="2020_09_30_services"><br>总而言之，使用Flutter来开发，我们可以绕过几个程序开发过程中比较耗时的步骤，这样使整个开发过程更快，更简单且更省心。</p><h5 id="3-更快的迭代速度-1"><a href="#3-更快的迭代速度-1" class="headerlink" title="3. 更快的迭代速度"></a><span id="jump2_3">3. 更快的迭代速度</span></h5><p>使用Flutter来开发迭代产品会更快。在大多数情况下，我们研发一个App需要Android端和iOS端都需要进行开发和维护，而Flutter只要一组人员就可以完成这个任务。在开发时间上至少节省了一倍。原因很简单，我们只需要编写一套代码就可以得到在各个应用平台相同的交互效果。任何基于2D的UI都可以在Flutter中实现，且不需要调用原生代码。<br>除此之外，Flutter使用声明式语法构建UI，根据我的经验，它可以显著提高开发速度。当涉及到UI效果调整时这是最明显的。</p><h5 id="4-无限接近原生的交互体验-1"><a href="#4-无限接近原生的交互体验-1" class="headerlink" title="4. 无限接近原生的交互体验"></a><span id="jump2_4">4. 无限接近原生的交互体验</span></h5><p>我们知道，App的性能是好的用户体验的关键。<br>尽管很难说出确切的数字，但是可以肯定地说，在大多数情况下，Flutter应用程序的性能与本机应用程序没有区别，甚至在复杂的UI动画场景中表现的更好。<br>为什么呢？与大多数跨平台框架不同的是，Flutter不依赖任何中间代码做映射。Flutter应用直接调用了底层代码，这就极大的提高了性能。<br>我们同样可以使用Flutter完全编译和发布应用程序。</p><h5 id="5-丰富的UI动画-1"><a href="#5-丰富的UI动画-1" class="headerlink" title="5. 丰富的UI动画"></a><span id="jump2_5">5. 丰富的UI动画</span></h5><p>Flutter的一个最大的优势就是可以随时修改屏幕上的任何控件，无论这个控件有多复杂。同样也支持直接使用原生控件来做UI动画。<br>下面是一个简单的自定义动画的示例：<br><img src="https://raw.githubusercontent.com/Johnson8888/blog_pages/master/images/2020_09_30_animate.png" alt="2020_09_30_animate"><br>同样的，使用Flutter生成动画更加灵活和通用，并且不会额外增加工作量。过渡动画、圆角、颜色、阴影、变换等，Flutter都能轻松实现。<br><a href="https://itsallwidgets.com/">这里</a>给大家提供更多的Demo。让我们更好的熟悉这些动画。</p><h5 id="6-独立的渲染引擎-1"><a href="#6-独立的渲染引擎-1" class="headerlink" title="6. 独立的渲染引擎"></a><span id="jump2_6">6. 独立的渲染引擎</span></h5><p>与其他框架相比，Flutter应有更多的能力。显然，这需要框架本身非常强大，且需要框架本身是一个高性能的框架。<br>Flutter是使用<a href="https://github.com/google/skia">Skia</a>作为底层的渲染引擎。有了Skia的支持，UI层可以在任何平台上进行渲染，且保持一致性。换句话说，我们不需要调整任何代码就可以将UI呈现在其他平台上，这极大的简化了开发过程。</p><h5 id="7-能够很容易与原生进行交互-1"><a href="#7-能够很容易与原生进行交互-1" class="headerlink" title="7. 能够很容易与原生进行交互"></a><span id="jump2_7">7. 能够很容易与原生进行交互</span></h5><p>除了UI之外，我们还有很多功能需要依赖原生的支持，比如获取GPS信息，蓝牙通信，传感器，照相机，相册等等。这些功能都可以通过Flutter的插件来实现。<br>当然有些时候这些插件也是不足以满足我们的需求。但是不用担心，Flutter使用的开发语言（Dart语言）与原生代码通信非常简单。只需要几行代码我们就可以实现原生与Flutter之间的交互，就可以实现任何你想调用原生功能的需求。<br>交互流程如下图：<br><img src="https://raw.githubusercontent.com/Johnson8888/blog_pages/master/images/2020_09_30_channel.png" alt="2020_09_30_channel"></p><h5 id="8-不只是能运行在移动端-1"><a href="#8-不只是能运行在移动端-1" class="headerlink" title="8. 不只是能运行在移动端"></a><span id="jump2_8">8. 不只是能运行在移动端</span></h5><p>Flutter不仅是可以在移动设备上使用，还支持Web端和桌面端。在2018年的I / O会议上，Google展示了Flutter Web的技术，这使得在浏览器中运行纯Flutter应用程序成为可能，且不需要修改任何源代码。<br>下面是演示视频：</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=927277621&bvid=BV1iT4y1c71E&cid=241986005&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;">    </iframe></div><p>不能打开视频的可以点击<a href="https://www.bilibili.com/video/BV1iT4y1c71E/">这里</a>查看<br>官方的这一操作，意味着Flutter从移动开发框架升级到了全平台开发框架的行列。<br>如果我们不需要在移动端做部署和使用，技术娴熟的Flutter程序员可以让Flutter在热门平台上运行，包括但不限于Android、iOS、Web浏览器、Windows、macOS、Linux甚至是嵌入式设备。同样的代码可以在这些任何平台上运行，且不需要修改任何Dart代码。</p><h4 id="从业务层来看，Flutter是一个好的选择吗？-1"><a href="#从业务层来看，Flutter是一个好的选择吗？-1" class="headerlink" title="从业务层来看，Flutter是一个好的选择吗？"></a><span id="jump3">从业务层来看，Flutter是一个好的选择吗？</span></h4><p>是的！是的！是的！<br>软件产品能保证性能和稳定性、人员容易招聘、产品能够快速的迭代和开发这些优势都能够给企业带来巨大的价值。一旦技术方案出现缺陷和存在任何方面的问题，都会给企业带来直接或间接的损失。<br>从这个角度来看，Flutter都是可以降低我们的风险的：</p><ul><li>目前Google正在研发<a href="https://www.techradar.com/news/google-fuchsia">Fuchsia OS</a>(与Flutter配合使用)，因此Flutter会继续投入研发人员维护和升级，不会中断。</li><li>使用Flutter的门槛并不高，因为社区中已经有了很多的人气很高的Android开发人员都在提倡和使用Flutter。</li><li>已经有很多大公司在使用，例如：阿里巴巴，Google Ads，AppTree，Reflectly和My Leaf等等，这是Flutter实力的证明。</li></ul><h4 id="为什么要尝试使用Fultter-1"><a href="#为什么要尝试使用Fultter-1" class="headerlink" title="为什么要尝试使用Fultter?"></a><span id="jump4">为什么要尝试使用Fultter?</span></h4><p>让我们总结一下Flutter的最突出优点：</p><ul><li>UI和业务逻辑代码在各个平台呈现效果一直</li><li>更快的开发速度</li><li>更快的迭代速度和更快的上线速度</li><li>无限接近原生的交互体验</li><li>更容易的自定UI和动画功能</li><li>独立的渲染引擎</li><li>不依赖于任何平台的UI组件</li><li>适用于更多的平台</li><li>商业风险控制在最小</li></ul><p>所以说，想开发跨平台的，性能优良的应用，Flutter是不二选择。Flutter正式成为最终的跨平台UI框架只是时间问题。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 1-2】在 Windows 10下配置Flutter开发环境</title>
      <link href="/windows-install-flutter.html"/>
      <url>/windows-install-flutter.html</url>
      
        <content type="html"><![CDATA[<h4 id="在-Windows-10下安装Flutter-Dart-Android-Studio-配置Flutter开发环境"><a href="#在-Windows-10下安装Flutter-Dart-Android-Studio-配置Flutter开发环境" class="headerlink" title="在 Windows 10下安装Flutter+Dart+Android Studio 配置Flutter开发环境"></a><strong>在 Windows 10下安装Flutter+Dart+Android Studio 配置Flutter开发环境</strong></h4><p><a href="https://johnson8888.github.io/2020/09/28/windows-install-flutter/">文章首发地址</a></p><h5 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a><strong>配置环境变量</strong></h5><p>由于部分网站被墙的原因，我们需要先配置Flutter国内镜像地址，这两个地址是由Flutter官方维护的，可以放心使用<br>首先我们找到<code>此电脑</code>点击右键，然后点击<code>属性</code></p><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_my_computer.png" alt="2020_10_07_my_computer"></p><p>然后点击<code>高级系统设置</code><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_heigh_setting.png" alt="2020_10_07_heigh_setting"></p><p>点击<code>高级</code>然后找到下面的<code>环境变量</code>并点击<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_huanjingbianliang.png" alt="2020_10_07_huanjingbianliang"><br>点击<code>新建</code><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_xinjian.png" alt="2020_10_07_xinjian"><br>变量名输入<code>PUB_HOSTED_URL</code> 变量值输入 <code>https://pub.flutter-io.cn</code> 然后点击<code>确定</code><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_input_pub.png" alt="2020_10_07_input_pub"><br>继续点击 <code>新建</code><br>变量名输入<code>FLUTTER_STORAGE_BASE_URL</code> 变量值输入 <code>https://storage.flutter-io.cn</code> 然后点击<code>确定</code><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_input_storage.png" alt="2020_10_07_input_storage"><br>到这里需要的环境变量就配置完成了</p><h5 id="开始安装Flutter"><a href="#开始安装Flutter" class="headerlink" title="开始安装Flutter"></a><strong>开始安装Flutter</strong></h5><ul><li><p>下载安装文件并解压缩<br><a href="https://flutter.dev/docs/development/tools/sdk/releases">点击进入官网下载需要的版本</a><br>如果不能打开该网站，<a href="https://pan.baidu.com/s/1SgNz14eVc1SDlHlTH7Y0mA">可去我的网盘去取版本是1.22.0</a> 提取码: awjy<br>下载完成后在新建一个文件夹解压缩，我这里选的是<code>C:\src\flutter</code><br>解压成功之后，我们需要将Flutter也配置到环境变量中，flutter文件夹下的<code>bin</code>目录路径(我这里是<code>C:\src\flutter\bin</code>)配置到环境变量中。打开配置环境变量的步骤参考 上面的步骤<code>配置环境变量</code><br>双击<code>Path</code>来添加<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_find_pth.png" alt="2020_10_07_find_pth"><br>将<code>C:\src\flutter\bin</code>配置进去<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_flutter_path.png" alt="2020_10_07_flutter_path"></p></li><li><p>运行 flutter doctor<br>将路径配置之后我们打开 终端工具<code>PowerShell</code> 输入 <code>flutter doctor</code>查看还有哪些需要配置。<code>flutter doctor</code>是Flutter官方提供的用来检测当前Flutter配置环境的工具，可以快速的帮我们发现问题。<br>运行之后我们会看到输出如下:<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_flutter_doctor_1.png" alt="2020_10_07_flutter_doctor_1"></p></li></ul><p>很明显我们还需要安装 <code>Android Studio</code>，Andriod Studio是Flutter官方支持的IDE工具。<br><a href="https://developer.android.com/studio">去Andriod Studio 官网下载</a>下载完成后，一路Next安装完成，然后启动Android Studio，第一次安装默认会安装很多依赖，这个等慢慢安装就可以了。<br>启动之后点击<code>File</code>-&gt;<code>Settings</code><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_android_studio_settings.png" alt="2020_10_07_android_studio_settings"></p><p>找到<code>Plugins</code>在输入框内输入<code>Flutter</code>点击安装<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_andriod_studio_install_flutter.png" alt="2020_10_07_andriod_studio_install_flutter"><br>安装<code>Flutter</code>的时候默认会要求安装<code>Dart</code><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_android_studio_install_dart.png" alt="2020_10_07_android_studio_install_dart"><br>安装后重启 <code>Andriod Studio</code></p><p>然后我们把<code>Android SDK</code>路径配置到系统变量里面<br>我们先找到<code>File</code>-&gt;<code>Other Settings</code>-&gt;<code>Default Project Structure..</code>并点击<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_android_sdk.png" alt="2020_10_07_android_sdk"><br>找到SDK的路径<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_android_sdk_path.png" alt="2020_10_07_android_sdk_path"><br>进入到文件下找到SDK文件夹有一个<code>platform-tools</code>的文件夹，复制这个路径添加到系统<code>Path</code>中<br>变量名是<code>ANDROID_HOME</code><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_adroid_home.png" alt="2020_10_07_adroid_home"></p><p>这时候我们再执行一次 <code>flutter doctor</code><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_doctor_error.png" alt="2020_10_07_doctor_error"><br>现在我们只需要再执行一次 <code>flutter doctor --android-licenses</code> 弹出的提示选择<code>y</code>或者是直接<code>回车</code>即可。<br>然后再运行一次<code>flutter doctor</code>已经没有错误提示了。<br>这样我们的Flutter的环境就配置完成了。</p><h5 id="安装Android-模拟器"><a href="#安装Android-模拟器" class="headerlink" title="安装Android 模拟器"></a><strong>安装Android 模拟器</strong></h5><p>打开Android Studio 找到右上角的<code>AVD Manager</code>并点击<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_android_studio_avd_manager.png" alt="2020_10_07_android_studio_avd_manager"></p><p>点击<code>Create Virtual Device...</code> 选择一个我们需要需要安装的模拟器，然后点击<code>Next</code><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_select_device.png" alt="2020_10_07_select_device"><br>在配置页面选择<code>Hardware - GLES 2.0</code><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_hardware_gles.png" alt="2020_10_07_hardware_gles"></p><h5 id="新建Flutter项目并运行"><a href="#新建Flutter项目并运行" class="headerlink" title="新建Flutter项目并运行"></a><strong>新建Flutter项目并运行</strong></h5><p>点击Android Studio 里面的 <code>File</code>-&gt;<code>New</code>-&gt;<code>New Flutter Project</code><br>新建项目并打开<br>选择我们刚刚安装好的模拟器，并且点击运行 就可以看到效果啦！<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_runing.png" alt="2020_10_07_runing"></p><h5 id="可能会遇到的问题"><a href="#可能会遇到的问题" class="headerlink" title="可能会遇到的问题"></a><strong>可能会遇到的问题</strong></h5><p>在执行 <code>flutter doctor --android-licenses</code>出现以下错误<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_fluuter_sdk_error.png" alt="2020_10_07_fluuter_sdk_error"><br>需要我们手动安装<code>Android SDK Platform-Tools</code><br>打开Android Studio 点击<code>File</code>-&gt;<code>Settings</code>-&gt;<code>Android SDK</code>找到<code>Android SDK Platform-Tools</code>安装即可！<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_error_platform_tools.png" alt="2020_10_07_error_platform_tools"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac下使用GitHub+Hexo搭建个人博客</title>
      <link href="/how-to-set-up-hexo-blog.html"/>
      <url>/how-to-set-up-hexo-blog.html</url>
      
        <content type="html"><![CDATA[<p>开始之前需要在电脑上安装好<a href="https://git-scm.com/">Git</a>和<a href="https://nodejs.org/en/">node.js</a>，Mac上可以使用Homebrew命令行工具来安装Git和node.js</p><h5 id="安装Homebrew"><a href="#安装Homebrew" class="headerlink" title="安装Homebrew"></a><strong>安装Homebrew</strong></h5><p>在命令行工具输入以下命令，如果已经安装过Homebrew可以忽略</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>&quot;</span></span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="Homebrew-安装-node-js"><a href="#Homebrew-安装-node-js" class="headerlink" title="Homebrew 安装 node.js"></a><strong>Homebrew 安装 node.js</strong></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure><p>安装后可以使用命令来检查是否安装成功<br>检查node</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v12.14.1</span><br></pre></td></tr></table></figure><p>检查<a href="https://www.npmjs.com/">npm</a>是否安装成功，npm是node.js的包管理工具，用它来安装hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6.13.4</span><br></pre></td></tr></table></figure><h5 id="Homebrew-安装git"><a href="#Homebrew-安装git" class="headerlink" title="Homebrew 安装git"></a><strong>Homebrew 安装git</strong></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure><p>检查git是否安装成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git version</span><br><span class="line">``` </span><br><span class="line">输出结果:</span><br><span class="line">``` bash</span><br><span class="line">git version 2.24.3 (Apple Git-128)</span><br></pre></td></tr></table></figure><h5 id="使用-npm-安装-hexo"><a href="#使用-npm-安装-hexo" class="headerlink" title="使用 npm 安装 hexo"></a><strong>使用 npm 安装 <a href="https://hexo.io/zh-cn/docs/">hexo</a></strong></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g hexo-cli</span><br><span class="line">``` </span><br><span class="line">安装完成后，在Desktop创建一个blog文件夹，在该文件夹下初始化我们的博客</span><br><span class="line">``` bash</span><br><span class="line"><span class="built_in">cd</span> ~/Desktop &amp;&amp; mkdir blog &amp;&amp; <span class="built_in">cd</span> blog</span><br><span class="line">``` </span><br><span class="line">在该文件件目录下执行博客初始化操作</span><br><span class="line">``` bash</span><br><span class="line"><span class="comment"># 会下载一些node.js的依赖文件</span></span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>初始化成功后，在blog目录下执行预览操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo s </span><br><span class="line">``` </span><br><span class="line">当看到如下输出就可以预览我们创建的博客了</span><br><span class="line">``` bash</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. </span><br></pre></td></tr></table></figure><p>预览效果如下</p><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/preview_hexo_20200928.jpg" alt="preview_hexo_20200928"></p><h5 id="配置客户端git-添加SSH-Key到github"><a href="#配置客户端git-添加SSH-Key到github" class="headerlink" title="配置客户端git  添加SSH Key到github"></a><strong>配置客户端git  添加SSH Key到github</strong></h5><p>如果已经配置过，该步骤可以忽略<br>在命令行输入配置用户名和账号的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;username&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;email@gmail.com&quot;</span></span><br></pre></td></tr></table></figure><p>其中 <code>username</code> 是你的用户名，<code>email@gmail.com</code>是你github的登录邮箱<br>然后通过终端命令生成SSH Key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;email@gmail.com&quot;</span></span><br></pre></td></tr></table></figure><p>如果已经创建过会出现 <code>Overwrite (y/n)? n</code>提示可以输入 <code>n</code>，如果没有创建过会要求我们输入密码，然后一路回车下去就行，执行完成后会在<code>~/.ssh/id_rsa.pub</code>目录下生成 需要使用的 key。</p><p>可以使用命令行输出key并复制</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>或者可以找到这个文件并打开它，复制里面的内容。</p><p>登录github账号 找到 <code>setting</code><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/setting_20200928.png" alt="setting_20200928"></p><p>先点击 <code> SSH and GPG keys</code> 然后再点击 <code>New SSH key</code> 进入到配置 SSH Key 的页面<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/select_sshkey_20200928.jpg?token=ABHYKC5WITD7CZYQDC4ABAK7OFO3W" alt="select_sshkey_20200928"></p><p>然后输入复制好的key的内容</p><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/set_my_pc_ssh_key_20200928.png?token=ABHYKC4PWIEGG63VBN3Q3NS7OFPEC" alt="set_my_pc_ssh_key_20200928"></p><p>点击 <code>Add SSH Key</code> 即可</p><h5 id="本地博客关联到Github主页"><a href="#本地博客关联到Github主页" class="headerlink" title="本地博客关联到Github主页"></a><strong>本地博客关联到Github主页</strong></h5><p>登录Github并且创建一个名字为 <code>username.githug.io</code> 的仓库，比如我的仓库名字为 <code>Johnson8888.github.io</code><br>因为我已经创建过了，所以会显示红色，如果创建过，会显示绿色的，然后点击创建。切记一定要选择 <code>Public</code>，否定不能访问。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/create_my_repo_20200928.png?token=ABHYKCYY4HSYNU4W6VVG5Q27OFPVO" alt="create_my_repo_20200928"></p><p>然后命令行切换到本地blog目录下 <code>cd ~/Desktop/blog</code><br>执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后开始修改配置文件 <code>~/Desktop/blog/_config.yml</code><br>修改 <code>deploy</code>部分为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:Johnson8888/Johnson8888.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>然后就可以把博客push到github了<br>在命令行执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成我们想要的博客文件</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="comment">#将本地的博客文件push到github</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p><code>hexo d </code>执行成功后，就可以查看我们的<a href="https://johnson8888.github.io/">Blog</a>了</p><h5 id="开始写博客"><a href="#开始写博客" class="headerlink" title="开始写博客"></a><strong>开始写博客</strong></h5><p>在命令行执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new firstPage.md </span><br></pre></td></tr></table></figure><p>会在 <code>~/Desktop/blog/source/_post</code>目录下生成 <code>firstPage.md</code> 打开这个文件就可以开心的写博客了<br>写完后重新执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>就可以同步博客到github</p><h4 id="Todo"><a href="#Todo" class="headerlink" title="Todo"></a><strong>Todo</strong></h4><ul><li>申请域名指向博客，这样就可以直接使用域名访问了</li><li>hexo支持很多模板样式 可以去<a href="https://hexo.io/themes/">官网</a>选择自己喜欢的使用</li></ul><h5 id="附-hexo常用命令"><a href="#附-hexo常用命令" class="headerlink" title="附 hexo常用命令"></a><strong>附 hexo常用命令</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;博客名称&quot;  &#x3D;&gt; hexo new &quot;博客名称&quot;   #这两个都是创建新文章，前者是简写模式</span><br><span class="line">hexo p  &#x3D;&gt; hexo publish</span><br><span class="line">hexo g  &#x3D;&gt; hexo generate  #生成</span><br><span class="line">hexo s  &#x3D;&gt; hexo server  #启动服务预览</span><br><span class="line">hexo d  &#x3D;&gt; hexo deploy  #部署  </span><br><span class="line"></span><br><span class="line">hexo server   #Hexo 会监视文件变动并自动更新，无须重启服务器。</span><br><span class="line">hexo server -s   #静态模式</span><br><span class="line">hexo server -p 5000   #更改端口</span><br><span class="line">hexo server -i 192.168.1.1   #自定义IP</span><br><span class="line">hexo clean   #清除缓存，网页正常情况下可以忽略此条命令</span><br><span class="line">hexo g   #生成静态网页</span><br><span class="line">hexo d   #开始部署</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
